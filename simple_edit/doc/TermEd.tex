\input wbuildmac.tex
\Class{TermEd}\Publicvars
\Table{TermEd}
XtNgWidth&XtCGWidth&int &40 \cr
XtNgHeight&XtCGHeight&int &25 \cr
XtNsize&XtCSize&int &8 \cr
XtNselTime&XtCSelTime&int &400 \cr
XtNtext&XtCText&String &"Hello World{\backslash}nHow are you?"\cr
XtNfg&XtCFg&XftColor&"White"\cr
XtNbg&XtCBg&XftColor&"Darkgreen"\cr
XtNcbg&XtCCbg&XftColor&"Red"\cr
XtNcfg&XtCCfg&XftColor&"Green"\cr
XtNhost&XtCHost&String &"localhost"\cr
XtNport&XtCPort&String &"10002"\cr
\endTable
\Section
\Publicvar{XtNgWidth}
int  gWidth = 40 

\Section
\Publicvar{XtNgHeight}
int  gHeight = 25 

\Section
\Publicvar{XtNsize}
int  size = 8 

\Section
\Publicvar{XtNselTime}
int  selTime = 400 

\Section
\Publicvar{XtNtext}
String  text = {\langle}String{\rangle}"Hello World{\backslash}nHow are you?"

\Section
\Publicvar{XtNfg}
{\langle}XftColor{\rangle} XftColor  fg = {\langle}String{\rangle}"White"

\Section
\Publicvar{XtNbg}
{\langle}XftColor{\rangle} XftColor  bg = {\langle}String{\rangle}"Darkgreen"

\Section
\Publicvar{XtNcbg}
{\langle}XftColor{\rangle} XftColor  cbg = {\langle}String{\rangle}"Red"

\Section
\Publicvar{XtNcfg}
{\langle}XftColor{\rangle} XftColor  cfg = {\langle}String{\rangle}"Green"

\Section
\Publicvar{XtNhost}
String  host = {\langle}String{\rangle}"localhost"

\Section
\Publicvar{XtNport}
String  port = {\langle}String{\rangle}"10002"

\End\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Translations
\Section
\Code
{\langle}Key{\rangle}Right: forward{\underline}char() \endCode


\Section
\Code
{\langle}Key{\rangle}Left: backward{\underline}char() \endCode


\Section
\Code
{\langle}Key{\rangle}Up: prev{\underline}line() \endCode


\Section
\Code
{\langle}Key{\rangle}Down: next{\underline}line() \endCode


\Section
\Code
{\langle}Key{\rangle}Return: key{\underline}return() \endCode


\Section
\Code
{\langle}Key{\rangle}Delete: key{\underline}del() \endCode


\Section
\Code
{\langle}Key{\rangle}BackSpace: key{\underline}backspace() \endCode


\Section
\Code
{\langle}Key{\rangle}Escape: kill{\underline}child() \endCode


\Section
\Code
{\langle}Key{\rangle}: insert{\underline}char() \endCode


\Section
\Code
{\langle}Btn1Down{\rangle}: button1{\underline}down() \endCode


\End\Actions
\Section
\Action{button1{\underline}down}\Code
void button1{\underline}down({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        if( {\dollar}INTERACTIVE == 0 ) {\lbrace}
                push{\underline}event({\dollar},
                1,                      /* BTN{\underline}DOWN */
                event-{\rangle}xbutton.x,
                event-{\rangle}xbutton.y,
                event-{\rangle}xbutton.time     /* time milliseconds */
                );
        {\rbrace}
{\rbrace}\endCode


\Section
\Action{kill{\underline}child}\Code
void kill{\underline}child({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}INTERACTIVE=1;
    undraw{\underline}selection({\dollar});
    te{\underline}pos1({\dollar});
    te{\underline}writeln({\dollar}, "kill");
    prog{\underline}kill({\dollar});
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{key{\underline}del}\Code
void key{\underline}del({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    undraw{\underline}selection({\dollar});
    te{\underline}del({\dollar});
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{key{\underline}backspace}\Code
void key{\underline}backspace({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    undraw{\underline}selection({\dollar});
    te{\underline}left({\dollar});
    te{\underline}del({\dollar});
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{key{\underline}return}\Code
void key{\underline}return({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    undraw{\underline}selection({\dollar});
    exec{\underline}line({\dollar});
    te{\underline}pos1({\dollar});
    te{\underline}down({\dollar});
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{insert{\underline}char}\Code
void insert{\underline}char({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    int len;
    unsigned char buf[32];
    KeySym key{\underline}sim;
    uint32{\underline}t ucs4;

    len = {\underline}XawLookupString({\dollar},(XKeyEvent *) event, (char*)buf,sizeof buf, {\ampersand}key{\underline}sim );
    if (len {\langle}= 0) return;
    
    FcUtf8ToUcs4 (buf, {\ampersand}ucs4, len);
    TRACE(1, "{\percent}d {\percent}lu",{\dollar}INTERACTIVE, ucs4 );
    
    if({\dollar}INTERACTIVE==0) {\lbrace}
         sln{\underline}printf({\dollar}sln, "KEY: {\percent}lu", ucs4);    
         return;
    {\rbrace}
    
    undraw{\underline}selection({\dollar});

    te{\underline}ins({\dollar});
    te{\underline}putc({\dollar},ucs4);

    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{prev{\underline}line}\Code
void prev{\underline}line({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    if( {\dollar}rsel.y == 0 ) return;
    {\dollar}rsel.y--;
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{next{\underline}line}\Code
void next{\underline}line({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    undraw{\underline}selection({\dollar});
    te{\underline}down({\dollar});
    // if( {\dollar}rsel.y {\langle} ({\dollar}gHeight-1) )
    // {\dollar}rsel.y++;
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{backward{\underline}char}\Code
void backward{\underline}char({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    if( {\dollar}rsel.x == 0 ) return;
    {\dollar}rsel.x--;
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Action{forward{\underline}char}\Code
void forward{\underline}char({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    if( {\dollar}rsel.x {\langle} ({\dollar}gWidth-1) )
        {\dollar}rsel.x ++;
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\End\Imports
\Section
\Code
{\incl} {\langle}stdint.h{\rangle}\endCode


\Section
\Code
{\incl} "mls.h"\endCode


\Section
\Code
{\incl} "xutil.h"\endCode


\Section
\Code
{\incl} "micro{\underline}vars.h"\endCode


\Section
\Code
{\incl} "converters-xft.h"\endCode


\Section
\Code
{\incl} "cp2.h"\endCode


\Section
\Code
{\incl} "slop4.h"\endCode


\Section
\Code
{\incl} {\langle}X11/Xaw/XawImP.h{\rangle}\endCode


\Section
\Code
{\incl} "slopnet.h"\endCode


\Section
\Code
{\incl} "mrb.h"\endCode


\Section
\Code
{\incl} "parser{\underline}util.h"\endCode


\Section
\Code
{\incl} "timer.h"\endCode


\End\Privatevars
\Section
\Code
struct {\lbrace} int type; ulong t, x,y; {\rbrace} termevent{\underline}t\endCode


\Section
\Code
XtIntervalId  timerid\endCode


\Section
\Code
Boolean  blink\endCode


\Section
\Code
XftFont * xftFont\endCode


\Section
\Code
XftDraw * draw\endCode


\Section
\Code
XftColor * col[4]\endCode


\Section
\Code
uint32{\underline}t * scr\endCode


\Section
\Code
int  grid{\underline}pix{\underline}width\endCode


\Section
\Code
int  grid{\underline}pix{\underline}height\endCode


\Section
\Code
Bool  selection{\underline}visible\endCode


\Section
\Code
XRectangle  rsel\endCode


\Section
\Code
XRectangle  rsel{\underline}old\endCode


\Section
\Code
GC  gc{\underline}copy\endCode


\Section
\Code
uint8{\underline}t * cmd\endCode


\Section
\Code
uint  cmd{\underline}len\endCode


\Section
\Code
int  progm\endCode


\Section
\Code
int  sln\endCode


\Section
\Code
int  cp2\endCode


\Section
\Code
XtInputId  cid\endCode


\Section
\Code
XtInputId  eid\endCode


\Section
\Code
Bool  INTERACTIVE\endCode


\Section
\Code
int  server{\underline}id\endCode


\Section
\Code
int  termevent{\underline}q\endCode


\End\Methods
\Section
\Code
class{\underline}initialize()
{\lbrace} converters{\underline}xft{\underline}init(); {\rbrace}\endCode


\Section
\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
    FcChar32 bat = 0x42;
    XGlyphInfo extents;
    Display *dpy = XtDisplay({\dollar});
    font{\underline}load({\dollar},{\dollar}size);
    XftTextExtents32(dpy, {\dollar}xftFont, {\ampersand}bat, 1, {\ampersand}extents);
    {\dollar}height = ({\dollar}grid{\underline}pix{\underline}height = {\dollar}xftFont-{\rangle}ascent + {\dollar}xftFont-{\rangle}descent) * {\dollar}gHeight;
    {\dollar}width  = ({\dollar}grid{\underline}pix{\underline}width = extents.width) * {\dollar}gWidth;
    {\dollar}draw=0;
    {\dollar}cmd=0;
    {\dollar}scr=0;
    {\dollar}sln=0;
    {\dollar}col[0] = {\ampersand} {\dollar}fg;
    {\dollar}col[1] = {\ampersand} {\dollar}bg;
    {\dollar}col[2] = {\ampersand} {\dollar}cfg;
    {\dollar}col[3] = {\ampersand} {\dollar}cbg;
    {\dollar}selection{\underline}visible = False;
    {\dollar}timerid = 0;
    {\dollar}gc{\underline}copy =  XtGetGC({\dollar}, 0,0 );
    {\dollar}progm = m{\underline}create(100,sizeof(char*));
    do{\underline}resize({\dollar});
    {\dollar}INTERACTIVE=1;

    /* command parser 2 */
    {\dollar}cp2 = cp2{\underline}init({\dollar});
    cp2{\underline}add({\dollar}cp2, "EXIT", comm{\underline}exit{\underline}cb );
    cp2{\underline}add({\dollar}cp2, "RUN", comm{\underline}run{\underline}cb );
    cp2{\underline}add({\dollar}cp2, "GOTOXY:", comm{\underline}gotoxy );
    cp2{\underline}add({\dollar}cp2, "WRITE:", comm{\underline}write );
    cp2{\underline}add({\dollar}cp2, "MEASURE{\underline}SCREEN", comm{\underline}measure{\underline}screen );
    cp2{\underline}add({\dollar}cp2, "RECTF:", comm{\underline}rectf );
    cp2{\underline}add({\dollar}cp2, "CLRSCR", comm{\underline}clrscr );
    cp2{\underline}add({\dollar}cp2, "CIRCLE:", comm{\underline}circle );
    cp2{\underline}add({\dollar}cp2, "LINE:", comm{\underline}line );
    cp2{\underline}add({\dollar}cp2, "POLL", comm{\underline}poll );
    cp2{\underline}add({\dollar}cp2, "ERR:", comm{\underline}err );           
    
    {\dollar}sln = sln{\underline}init();
    {\dollar}termevent{\underline}q = mro{\underline}init(10,sizeof(termevent{\underline}t));

    try{\underline}connect({\dollar},NULL);
    
{\rbrace}\endCode


\Section
\Code
destroy({\dollar})
{\lbrace}
     cp2{\underline}free({\dollar}cp2);
     
    if( {\dollar}draw) XftDrawDestroy( {\dollar}draw );
    {\dollar}draw=0;
    font{\underline}free({\dollar});
    if( {\dollar}scr ) {\lbrace} free({\dollar}scr); {\dollar}scr=0; {\rbrace}
    if( {\dollar}cmd ) {\lbrace} free({\dollar}cmd); {\dollar}cmd=0; {\rbrace}
    if( {\dollar}progm ) {\lbrace} m{\underline}free{\underline}strings( {\dollar}progm, 0); {\dollar}progm=0; {\rbrace}
    if( {\dollar}sln ) prog{\underline}kill({\dollar});

{\rbrace}\endCode


\Section
\Code
Boolean  set{\underline}values(Widget  old, Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
    if( {\dollar}old{\dollar}size != {\dollar}size ) {\lbrace}
        font{\underline}free({\dollar});
        font{\underline}load({\dollar},{\dollar}size);
        {\dollar}resize( {\dollar} );
    {\rbrace}
    return True; /* call expose */
{\rbrace}\endCode


\Section
\Code
resize({\dollar})
{\lbrace}
    {\dollar}gWidth  = {\dollar}width / {\dollar}grid{\underline}pix{\underline}width;
    {\dollar}gHeight = {\dollar}height / {\dollar}grid{\underline}pix{\underline}height;
    do{\underline}resize({\dollar});
{\rbrace}\endCode


\Section
\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace}
    Display *dpy = XtDisplay({\dollar});
    if(!{\dollar}draw )
        {\dollar}draw = XftDrawCreate(dpy, XtWindow({\dollar}),
                              DefaultVisual(dpy, DefaultScreen(dpy)), None);
    test{\underline}convert({\dollar});
    full{\underline}draw({\dollar});
    selection{\underline}draw({\dollar});
    /*   FcChar32 bat = 0xf240 + {\dollar}status;
        XftDrawString32({\dollar}draw, {\dollar}col[{\dollar}status],{\dollar}xftFont,0,{\dollar}xftFont-{\rangle}ascent,{\ampersand}bat,1);
    */
    printf("w WxH={\percent}dx{\percent}d{\backslash}n",{\dollar}width, {\dollar}height );
{\rbrace}\endCode


\End\Utilities
\Section
\Code
font{\underline}free({\dollar})
{\lbrace}
    Display *dpy = XtDisplay({\dollar});
    if( {\dollar}xftFont ) XftFontClose(dpy, {\dollar}xftFont );
    {\dollar}xftFont=0;
{\rbrace}\endCode


\Section
\Code
font{\underline}load({\dollar}, int  size)
{\lbrace}
    Display *dpy = XtDisplay({\dollar});
    int screen = DefaultScreen(dpy);
    char fontname[30];
    sprintf(fontname, "Source Code Pro-{\percent}d", {\dollar}size );
    font{\underline}free({\dollar});
    {\dollar}xftFont = XftFontOpenName(dpy,screen, fontname );
{\rbrace}\endCode


\Section
\Code
draw{\underline}glyph{\underline}color({\dollar}, int  x, int  y, int  fg, int  bg, uint32{\underline}t  ucs4)
{\lbrace}
    int x0,y0,w,h;
    uint32{\underline}t glyph;

    x0 = x * {\dollar}grid{\underline}pix{\underline}width;
    y0 = y * {\dollar}grid{\underline}pix{\underline}height;
    w = {\dollar}grid{\underline}pix{\underline}width;
    h = {\dollar}grid{\underline}pix{\underline}height;

    if( bg {\rangle}= 0 ) XftDrawRect({\dollar}draw,{\dollar}col[bg], x0,y0,w,h );
    if( ucs4 == 0 {\bar}{\bar} ucs4 == 32 ) return;

    glyph = XftCharIndex ( XtDisplay({\dollar}), {\dollar}xftFont, ucs4 );
    XftDrawGlyphs ({\dollar}draw, {\dollar}col[fg], {\dollar}xftFont,
                   x0, y0+{\dollar}xftFont-{\rangle}ascent,
                   {\ampersand}glyph, 1);
{\rbrace}\endCode


\Section
\Code
full{\underline}draw({\dollar})
{\lbrace}
    int x,y;
    XftDrawRect({\dollar}draw,{\dollar}col[1], 0,0, {\dollar}width, {\dollar}height );
    for(x=0;x{\langle}{\dollar}gWidth;x++) {\lbrace}
        for(y=0;y{\langle}{\dollar}gHeight;y++) {\lbrace}
            draw{\underline}glyph{\underline}color({\dollar},x,y,0,-1,{\dollar}scr[x + y * {\dollar}gWidth ] );
        {\rbrace}
    {\rbrace}
{\rbrace}\endCode


\Section
\Code
putcharat({\dollar}, int  x, int  y, uint32{\underline}t  ucs4)
{\lbrace}
    if( x {\langle} {\dollar}gWidth {\ampersand}{\ampersand} x {\rangle}= 0 {\ampersand}{\ampersand} y {\langle} {\dollar}gHeight {\ampersand}{\ampersand} y {\rangle}= 0 )
        {\lbrace}
            {\dollar}scr[x + y * {\dollar}gWidth ] = ucs4;
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
uint32{\underline}t  getcharat({\dollar}, int  x, int  y)
{\lbrace}
    if( x {\langle} {\dollar}gWidth {\ampersand}{\ampersand} x {\rangle}= 0 {\ampersand}{\ampersand} y {\langle} {\dollar}gHeight {\ampersand}{\ampersand} y {\rangle}= 0 )
        {\lbrace}
            return {\dollar}scr[x + y * {\dollar}gWidth ];
        {\rbrace}

    return 0;
{\rbrace}\endCode


\Section
\Code
drawcharat({\dollar}, int  x, int  y, int  fg, int  bg)
{\lbrace}
    if( x {\langle} {\dollar}gWidth {\ampersand}{\ampersand} x {\rangle}= 0 {\ampersand}{\ampersand} y {\langle} {\dollar}gHeight {\ampersand}{\ampersand} y {\rangle}= 0 )
        {\lbrace}
            draw{\underline}glyph{\underline}color({\dollar},x,y,fg,bg,{\dollar}scr[x + y * {\dollar}gWidth ] );
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
draw{\underline}string({\dollar}, int  x, int  y, char * str)
{\lbrace}
    int len,l;
    unsigned char *string = (void*) str;
    uint32{\underline}t ucs4;
    len = strlen( (char*)string);
    x=0; y=0;
    while(1) {\lbrace}
        l = FcUtf8ToUcs4 (string, {\ampersand}ucs4, len);
        if( l{\langle}= 0 {\bar}{\bar} len {\langle}=0 ) return;
        if( ucs4 == '{\backslash}n' ) {\lbrace} x=0; y++; {\rbrace}
        if( x {\rangle}= {\dollar}gWidth ) {\lbrace} x=0; y++; {\rbrace}
        if( y {\rangle}= {\dollar}gHeight ) {\lbrace} y=0; {\rbrace}
        if( ucs4 {\rangle}=' ' ) {\lbrace}
            putcharat({\dollar},x,y,ucs4);
            x++;
        {\rbrace}
        string += l;
        len -= l;
    {\rbrace}
{\rbrace}\endCode


\Section
\Code
test{\underline}convert({\dollar})
{\lbrace}
    draw{\underline}string({\dollar}, 0, {\dollar}gHeight / 2, {\dollar}text );
{\rbrace}\endCode


\Section
\Code
selection{\underline}timer({\dollar}, XtIntervalId * id)
{\lbrace}
    int nr = {\dollar}blink ? 2 : 0;
    if( {\dollar}selection{\underline}visible ) {\lbrace}
        drawcharat({\dollar}, {\dollar}rsel{\underline}old.x, {\dollar}rsel{\underline}old.y, nr, nr+1 );
        {\dollar}blink = ! {\dollar}blink;
        if( id==NULL {\ampersand}{\ampersand} {\dollar}timerid ) XtRemoveTimeOut({\dollar}timerid);
        {\dollar}timerid = XtAppAddTimeOut(XtWidgetToApplicationContext({\dollar}), {\dollar}selTime,
                        (void*)selection{\underline}timer, {\dollar} );
    {\rbrace}
    else {\dollar}timerid=0;
{\rbrace}\endCode


\Section
\Code
undraw{\underline}selection({\dollar})
{\lbrace}
    if( {\dollar}selection{\underline}visible ) {\lbrace}
        drawcharat({\dollar}, {\dollar}rsel{\underline}old.x, {\dollar}rsel{\underline}old.y, 0,1 );
        {\dollar}selection{\underline}visible = False;
        if({\dollar}timerid) {\lbrace}
            XtRemoveTimeOut({\dollar}timerid);
            {\dollar}timerid=0;
        {\rbrace}
    {\rbrace}
{\rbrace}\endCode


\Section
\Code
selection{\underline}draw({\dollar})
{\lbrace}
    if( {\dollar}rsel.x {\rangle}= {\dollar}gWidth ) {\dollar}rsel.x = {\dollar}gWidth-1;
    if( {\dollar}rsel.y {\rangle}= {\dollar}gHeight ) {\dollar}rsel.y = {\dollar}gHeight-1;
    undraw{\underline}selection({\dollar});
    {\dollar}selection{\underline}visible = True;
    {\dollar}rsel{\underline}old = {\dollar}rsel;
    {\dollar}blink = True; selection{\underline}timer({\dollar},0);
{\rbrace}\endCode


\Section
\Code
scr{\underline}scroll{\underline}up({\dollar})
{\lbrace}
        memcpy( {\dollar}scr, {\dollar}scr + {\dollar}gWidth,
                ({\dollar}gWidth*({\dollar}gHeight-1))*4 );
        memset( {\dollar}scr + {\dollar}gWidth*({\dollar}gHeight-1), 0, {\dollar}gWidth*4 );
{\rbrace}\endCode


\Section
\Code
pix{\underline}scroll{\underline}up({\dollar})
{\lbrace}
/*
      XCopyArea(display, src, dest, gc, src{\underline}x, src{\underline}y, width, height,  dest{\underline}x, dest{\underline}y)
      Display *display;
      Drawable src, dest;
      GC gc;
      int src{\underline}x, src{\underline}y;
      unsigned int width, height;
      int dest{\underline}x, dest{\underline}y;
*/
    XCopyArea(XtDisplay({\dollar}), XtWindow({\dollar}), XtWindow({\dollar}), DefaultGC(XtDisplay({\dollar}),0),
              0, {\dollar}grid{\underline}pix{\underline}height,
              {\dollar}grid{\underline}pix{\underline}width * ({\dollar}gWidth),
              {\dollar}grid{\underline}pix{\underline}height * ({\dollar}gHeight-1),
              0,0 );

    /* clear background */
    XftDrawRect({\dollar}draw,{\dollar}col[1],
    0,      {\dollar}grid{\underline}pix{\underline}height * ({\dollar}gHeight-1),
    {\dollar}width, {\dollar}grid{\underline}pix{\underline}height );

{\rbrace}\endCode


\Section
\Code
te{\underline}pos1({\dollar})
{\lbrace}
    {\dollar}rsel.x = 0;
{\rbrace}\endCode


\Section
\Code
te{\underline}tab({\dollar})
{\lbrace}
    int x = {\dollar}rsel.x;
    x /= 8;
    x ++;
    x *= 8;
    if( x {\langle} {\dollar}gWidth ) {\dollar}rsel.x = x;
{\rbrace}\endCode


\Section
\Code
te{\underline}down({\dollar})
{\lbrace}
    if( {\dollar}rsel.y {\langle} ({\dollar}gHeight-1) ) {\lbrace}
        {\dollar}rsel.y++;
        return;
    {\rbrace}

    pix{\underline}scroll{\underline}up({\dollar});
    scr{\underline}scroll{\underline}up({\dollar});
{\rbrace}\endCode


\Section
\Code
Bool  te{\underline}parse({\dollar}, uint32{\underline}t  ucs4)
{\lbrace}
    switch( ucs4 ) {\lbrace}
    default: break;
    case 10: te{\underline}pos1({\dollar}); te{\underline}down({\dollar}); return True;
    case '{\backslash}t': te{\underline}tab({\dollar}); return True;
    case 13: te{\underline}pos1({\dollar}); return True;
    case 12: te{\underline}clrscr({\dollar}); return True; 
    {\rbrace}
    return False;
{\rbrace}\endCode


\Section
\Code
te{\underline}gotoxy({\dollar}, int  x, int  y)
{\lbrace}
    undraw{\underline}selection({\dollar});
    if( x {\rangle}= {\dollar}gWidth ) x={\dollar}gWidth-1;
    if( y {\rangle}= {\dollar}gHeight ) x={\dollar}gHeight-1;
    {\dollar}rsel.x = x;
    {\dollar}rsel.y = y;
    selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Code
te{\underline}right({\dollar})
{\lbrace}
    if( {\dollar}rsel.x {\langle} ({\dollar}gWidth-1) ) {\lbrace}
        {\dollar}rsel.x++;
        return;
    {\rbrace}
    te{\underline}pos1({\dollar});
    te{\underline}down({\dollar});
{\rbrace}\endCode


\Section
\Code
pix{\underline}del({\dollar})
{\lbrace}
   int x0,y0,x1,y1,w,h,x,y;
   x = {\dollar}rsel.x; y={\dollar}rsel.y;
   /*-----------------------*/
   /* destination           */
   x0 = x;
   y0 = y;
   /*-----------------------*/
   /* width, height         */
   w = {\dollar}gWidth - (x+1);
   h = 1;
   /*-----------------------*/
   /* source                */
   x1 = x0+1;
   y1 = y0;
   /*-----------------------*/
   /* transformation        */
   w   *= {\dollar}grid{\underline}pix{\underline}width;
   x0  *= {\dollar}grid{\underline}pix{\underline}width;
   x1  *= {\dollar}grid{\underline}pix{\underline}width;
   h   *= {\dollar}grid{\underline}pix{\underline}height;
   y0  *= {\dollar}grid{\underline}pix{\underline}height;
   y1  *= {\dollar}grid{\underline}pix{\underline}height;

   XCopyArea(XtDisplay({\dollar}), XtWindow({\dollar}), XtWindow({\dollar}), DefaultGC(XtDisplay({\dollar}),0),
             x1,y1,w,h, /* source */
             x0,y0      /* destination */
             );
{\rbrace}\endCode


\Section
\Code
pix{\underline}ins({\dollar})
{\lbrace}
   int x0,y0,x1,y1,w,h,x,y;
   x = {\dollar}rsel.x; y={\dollar}rsel.y;
   /*-----------------------*/
   /* destination           */
   x0 = x+1;
   y0 = y;
   /*-----------------------*/
   /* width, height         */
   w = {\dollar}gWidth - (x+1);
   h = 1;
   /*-----------------------*/
   /* source                */
   x1 = x;
   y1 = y;
   /*-----------------------*/
   /* transformation        */
   w   *= {\dollar}grid{\underline}pix{\underline}width;
   x0  *= {\dollar}grid{\underline}pix{\underline}width;
   x1  *= {\dollar}grid{\underline}pix{\underline}width;
   h   *= {\dollar}grid{\underline}pix{\underline}height;
   y0  *= {\dollar}grid{\underline}pix{\underline}height;
   y1  *= {\dollar}grid{\underline}pix{\underline}height;

   XCopyArea(XtDisplay({\dollar}), XtWindow({\dollar}), XtWindow({\dollar}), DefaultGC(XtDisplay({\dollar}),0),
             x1,y1,w,h, /* source */
             x0,y0      /* destination */
             );
{\rbrace}\endCode


\Section
\Code
te{\underline}ins({\dollar})
{\lbrace}
   int i,x,y;
   x = {\dollar}rsel.x; y={\dollar}rsel.y;
   uint32{\underline}t *s = {\dollar}scr+y* {\dollar}gWidth;

   /* letztes zeichen der zeile mit {\langle}null{\rangle} füllen */
   if( x == {\dollar}gWidth -1 ) {\lbrace}
      s[x] = 0;
      return;
   {\rbrace}

   for(i={\dollar}gWidth-2; i{\rangle}=x ; i-- )
              s[i+1] = s[i];
   pix{\underline}ins({\dollar});
   s[x] = 32;
{\rbrace}\endCode


\Section
\Code
te{\underline}del({\dollar})
{\lbrace}
   uint16{\underline}t i,x,y;
   x = {\dollar}rsel.x; y={\dollar}rsel.y;
   uint32{\underline}t *s = {\dollar}scr+y* {\dollar}gWidth;

   /* letztes zeichen der zeile mit {\langle}null{\rangle} füllen */
   if( x == {\dollar}gWidth -1 ) {\lbrace}
      s[x] = 0;
      return;
   {\rbrace}

   for(i=x+1; i{\langle} {\dollar}gWidth; i++ )
              s[i-1] = s[i];
   pix{\underline}del({\dollar});
{\rbrace}\endCode


\Section
\Code
te{\underline}putc({\dollar}, uint32{\underline}t  ucs4)
{\lbrace}
    if( {\dollar}rsel.x {\rangle}= {\dollar}gWidth ) {\dollar}rsel.x = {\dollar}gWidth-1;
    if( {\dollar}rsel.y {\rangle}= {\dollar}gHeight ) {\dollar}rsel.y = {\dollar}gHeight-1;
    if( te{\underline}parse({\dollar},ucs4) ) return;
    putcharat({\dollar}, {\dollar}rsel.x, {\dollar}rsel.y,ucs4);
    drawcharat({\dollar}, {\dollar}rsel.x, {\dollar}rsel.y, 0,1 );
    {\dollar}selection{\underline}visible = False;
    te{\underline}right({\dollar});
{\rbrace}\endCode


\Section
\Code
te{\underline}home({\dollar})
{\lbrace}
    undraw{\underline}selection({\dollar});
    {\dollar}rsel.x = 0; {\dollar}rsel.y=0;
    selection{\underline}draw({\dollar});  
{\rbrace}\endCode


\Section
\Code
te{\underline}clrscr({\dollar})
{\lbrace}       
    memset({\dollar}scr,0,{\dollar}gWidth * {\dollar}gHeight * 4 );
    full{\underline}draw({\dollar});
    {\dollar}selection{\underline}visible = False;
    te{\underline}home({\dollar});
{\rbrace}\endCode


\Section
\Code
te{\underline}left({\dollar})
{\lbrace}
    if( {\dollar}rsel.x == 0 ) return;
    {\dollar}rsel.x--;
{\rbrace}\endCode


\Section
\Code
exec{\underline}line({\dollar})
{\lbrace}
    int i,len, space{\underline}left;
    unsigned char *dest;
    // char *string = malloc( {\dollar}gWidth * 6 + 2 );
    char *string = (void*){\dollar}cmd;
    uint32{\underline}t *s = {\dollar}scr + {\dollar}rsel.y * {\dollar}gWidth;
    dest = (void*)string;
    space{\underline}left = {\dollar}cmd{\underline}len;
    for( i=0; i{\langle} {\dollar}gWidth; i++ )
        {\lbrace}
            if( space{\underline}left {\langle} 7 ) break;
            len = FcUcs4ToUtf8( *s++, dest );
            dest+=len;
            space{\underline}left -= len;
        {\rbrace}
    *dest = 0;
    printf("str: {\percent}s{\backslash}n", string );

    /* check if there is a line number prefix */
    if(! prog{\underline}insert{\underline}line({\dollar}, string) ) return;

    if( strncmp( string, "list", 4 ) == 0 ) prog{\underline}list({\dollar});
    else if( strncmp( string, "save", 4 ) == 0 ) prog{\underline}save({\dollar});
    else if( strncmp( string, "load", 4 ) == 0 ) prog{\underline}load({\dollar});
    else if( strncmp( string, "run", 3 ) == 0 ) prog{\underline}run({\dollar});
    else if( strncmp( string, "parse", 5 ) == 0 ) prog{\underline}parse({\dollar});
    else if( strncmp( string, "del", 3 ) == 0 ) prog{\underline}del({\dollar});
    else if( strncmp( string, "import",6) == 0 ) prog{\underline}import({\dollar}); 
    else if( {\dollar}sln ) prog{\underline}interpret({\dollar});
{\rbrace}\endCode


\Section
\Code
prog{\underline}interpret({\dollar})
{\lbrace}
    char *s = (void*){\dollar}cmd;
    while(*s {\ampersand}{\ampersand} *s == '{\rangle}' ) s++;
    /* dprintf( {\dollar}sln-{\rangle}fd[3], "{\percent}s{\backslash}n", s ); */
{\rbrace}\endCode


\Section
\Code
prog{\underline}child{\underline}pipe{\underline}read({\dollar}, int  pipe)
{\lbrace}

        int buf = 0;
      
      if( strncmp(m{\underline}buf(buf),"RUN",3)==0 ) {\lbrace}
          {\dollar}INTERACTIVE=0;
          TRACE(2, "interactive mode off" );
      {\rbrace}
      else if( strncmp(m{\underline}buf(buf),"EXIT",4)==0 ) {\lbrace}
          TRACE(2, "interactive mode ON" );
          {\dollar}INTERACTIVE=1;
          te{\underline}pos1({\dollar}); te{\underline}writeln({\dollar},"exit");
      {\rbrace}

   selection{\underline}draw({\dollar});
{\rbrace}\endCode


\Section
\Code
act{\underline}input({\dollar}, XtIntervalId * id)
{\lbrace}
        if( sln{\underline}not{\underline}connected({\dollar}sln) ) return;
        if( {\dollar}cid ) return;
        XtAppContext app = XtWidgetToApplicationContext({\dollar});             
        {\dollar}cid = XtAppAddInput( app,
                   sln{\underline}get{\underline}fd({\dollar}sln),
                   (XtPointer)XtInputReadMask,
                   (XtInputCallbackProc)prog{\underline}child{\underline}read,
                   {\dollar} );
        WARN("input re-enabled");
{\rbrace}\endCode


\Section
\Code
prog{\underline}child{\underline}read({\dollar}, int * source, XtInputId * id)
{\lbrace}
        static int t{\underline}start;
        static int count = 0;
        TRACE(1,"");

        if( count == 0 ) {\lbrace}
            t{\underline}start = timer{\underline}get{\underline}ms();   
        {\rbrace}

        if( ++count {\rangle} 5 ) {\lbrace}
            
            int  e = timer{\underline}diff{\underline}ms(t{\underline}start);
            TRACE(1,"timer {\percent}d {\percent}d {\percent}d",e,t{\underline}start, timer{\underline}get{\underline}ms());
            if( e  {\langle} 40 ) {\lbrace}
                XtAppContext app = XtWidgetToApplicationContext({\dollar});    
                XtRemoveInput({\dollar}cid); {\dollar}cid = 0;
                XtAppAddTimeOut(app , 100,(XtTimerCallbackProc) act{\underline}input, {\dollar} ); 
                WARN("timer ovf. input suspended");
            {\rbrace}
            count=0;
        {\rbrace}
        
        if( sln{\underline}input{\underline}cb({\dollar}sln) ) {\lbrace}
            TRACE(1,"server died" );
            XtRemoveInput(*id);
        {\rbrace}
{\rbrace}\endCode


\Section
 starte das program
   beginne mit erster zeile oder der angegeben
   beispiel "run 200" startet bei zeile 200
   


\Code
prog{\underline}run({\dollar})
{\lbrace}
        int line,match;
        char *s =(char*) {\dollar}cmd+3;
        int arg;
        line=0;
        /* falls eine zeilennummer angegeben wurde, diese zeile suchen */       
        if(! get{\underline}num({\ampersand}s,{\ampersand}arg) ) {\lbrace}
            match  = progm{\underline}find( {\dollar}progm, arg, {\ampersand}line );
            if( match != 0 ) {\lbrace}
                te{\underline}write({\dollar}, "{\backslash}nerror can not find line{\backslash}n");
                return;
            {\rbrace}
        {\rbrace}
        int buf = m{\underline}create(10240,1);
        int crc = slop{\underline}encode{\underline}str( buf, 0, "PUT:" );
        char num[16]; 
        for( ; line {\langle} m{\underline}len({\dollar}progm); line++ )
        {\lbrace}
           s = STR({\dollar}progm,line);
           /* sprintf( num, "{\percent}u:", *(uint32{\underline}t*)s );
              crc = slop{\underline}encode{\underline}str(buf,crc,num);       */   
           crc = slop{\underline}encode{\underline}str(buf,crc,s+4);
           crc = slop{\underline}encode(buf,crc,10);
        {\rbrace}
        slop{\underline}encode(buf,crc,-1);
        sock{\underline}write( sln{\underline}get{\underline}fd({\dollar}sln), buf);
        m{\underline}free(buf);
{\rbrace}\endCode


\Section
\Code
char * progm{\underline}alloc({\dollar}, uint32{\underline}t  ln, char * s)
{\lbrace}
        char *buf = malloc( 5 + strlen(s) );
        *(uint32{\underline}t *)buf = ln;
        while( isspace(*s) ) s++;
        strcpy( buf +4, s );
        return buf;
{\rbrace}\endCode


\Section
\Code
progm{\underline}insert({\dollar}, int  i, uint32{\underline}t  arg, char * s)
{\lbrace}
        m{\underline}ins({\dollar}progm,i, 1);
        STR({\dollar}progm, i) = progm{\underline}alloc({\dollar},arg,s);
{\rbrace}\endCode


\Section
\Code
progm{\underline}overwrite({\dollar}, int  i, uint32{\underline}t  arg, char * s)
{\lbrace}
        free( STR({\dollar}progm,i));
        STR({\dollar}progm, i) = progm{\underline}alloc({\dollar},arg,s);
{\rbrace}\endCode


\Section
\Code
progm{\underline}append({\dollar}, uint32{\underline}t  arg, char * s)
{\lbrace}
        char *buf = progm{\underline}alloc({\dollar},arg,s);
        m{\underline}put( {\dollar}progm, {\ampersand}buf );
{\rbrace}\endCode


\Section
finde zeile {\tt num} im puffer
  returns: match
  {\tt *pos} == zeilennummer
  match == 0 : gefunden
  match <  0 : num größte zeile
  match >  1 : *pos größer als {\tt num}


\Code
int  progm{\underline}find(int  prog, uint32{\underline}t  num, int * pos)
{\lbrace}
        int i;
        uint32{\underline}t n;
        char *s;

        for(i=0;i{\langle}m{\underline}len(prog);i++) {\lbrace}
          s= STR(prog,i);
          n = *(uint32{\underline}t *) s;
          if( n == num ) {\lbrace} *pos=i; return 0; {\rbrace}
          else if( n {\rangle} num ) {\lbrace} *pos=i; return 1; {\rbrace};
        {\rbrace}
        *pos = i;
        return -1;
{\rbrace}\endCode


\Section
\Code
progm{\underline}put({\dollar}, uint32{\underline}t  arg, char * ln)
{\lbrace}
        int i;
        uint32{\underline}t n;
        char *s;

        for(i=0;i{\langle}m{\underline}len({\dollar}progm);i++) {\lbrace}
          s= STR({\dollar}progm,i);
          n = *(uint32{\underline}t *) s;
          if( n == arg ) {\lbrace} progm{\underline}overwrite( {\dollar}, i, arg, ln ); return; {\rbrace}
          else if( n {\rangle} arg ) {\lbrace} progm{\underline}insert({\dollar}, i, arg, ln ); return; {\rbrace}
        {\rbrace}
        progm{\underline}append({\dollar},arg, ln );
{\rbrace}\endCode


\Section
\Code
Bool  prog{\underline}insert{\underline}line({\dollar}, char * buf)
{\lbrace}
        char *s = (void*) buf;
        char *endp;
        int arg;

        arg = strtol( s,{\ampersand}endp,10);
        if( s == endp ) {\lbrace} return 1; {\rbrace}

        progm{\underline}put({\dollar}, arg, endp );
        return 0;
{\rbrace}\endCode


\Section
load a program file to memory
  syntax: load filename




\Code
prog{\underline}error({\dollar}, char * s)
{\lbrace}
        te{\underline}down({\dollar});
        te{\underline}pos1({\dollar});
        te{\underline}write({\dollar},s);
        te{\underline}down({\dollar});
        te{\underline}pos1({\dollar});
{\rbrace}\endCode


\Section
\Code
prog{\underline}load({\dollar})
{\lbrace}
        char *s = (void*){\dollar}cmd+5;
        int p = m{\underline}create(20,1);

        while( *s {\ampersand}{\ampersand} ! isspace(*s) )
               m{\underline}putc( p, *s++ );
        m{\underline}putc(p,0);

        FILE *fp = fopen( m{\underline}buf(p), "r" );
        if( !fp ) {\lbrace} prog{\underline}error( {\dollar}, "file read error" ); goto leave; {\rbrace}
        m{\underline}clear(p);


        while( m{\underline}fscan2( p, '{\backslash}n', fp ) == '{\backslash}n' ) {\lbrace}
                prog{\underline}insert{\underline}line({\dollar},m{\underline}buf(p));
                m{\underline}clear(p);
        {\rbrace}

        fclose(fp);
        leave: m{\underline}free(p);

{\rbrace}\endCode


\Section
import text file to editor buffer
  syntax: import <filename> [startnumber] [step]
  


\Code
prog{\underline}import({\dollar})
{\lbrace}
        int line{\underline}num = 1000;
        int step = 10;
        char *filename = "";
        char *s = (void*){\dollar}cmd+7;

        int args = m{\underline}split( 0, s,32, 1 );
        if( m{\underline}len(args) {\rangle} 0 )
            filename = STR(args,0);
        if( m{\underline}len(args) {\rangle} 1 )
            line{\underline}num = atoi( STR(args,1) );
        if( m{\underline}len(args) {\rangle} 2 )
            step = atoi( STR(args,2) );
            

        FILE *fp = fopen( filename, "r" );
        if( !fp ) {\lbrace}
            prog{\underline}error( {\dollar}, "file read error" );
            goto leave;
        {\rbrace}

        int buf = m{\underline}create(100,1);
        while( m{\underline}fscan2( buf, '{\backslash}n', fp ) == '{\backslash}n' ) {\lbrace}
                progm{\underline}put({\dollar}, line{\underline}num, m{\underline}buf(buf) );
                m{\underline}clear(buf);
                line{\underline}num += step;
        {\rbrace}

        fclose(fp);
        leave: m{\underline}free(buf);
        m{\underline}free{\underline}strings(args,0);
{\rbrace}\endCode


\Section
save a program file to filesystem
  syntax: save filename <n>
  falls <n> == 1 wird die datei ohne zeilennummern gespeichert



\Code
prog{\underline}save({\dollar})
{\lbrace}
        char *s = (void*){\dollar}cmd+5;
        char *filename = "";
        char *option = "0";
        
        int args = m{\underline}split( 0,s,32,1);
        if( m{\underline}len(args) {\rangle} 0 )
           filename = STR(args,0);         
        if( m{\underline}len(args) {\rangle} 1 )
           option   = STR(args,1);
           
        FILE *fp = fopen( filename, "w" );
        if( !fp ) {\lbrace} prog{\underline}error( {\dollar}, "file write error" ); goto leave; {\rbrace}
        int i;
        for(i=0;i{\langle}m{\underline}len({\dollar}progm);i++)
        {\lbrace}
                s = STR({\dollar}progm,i);
                uint32{\underline}t n = *(uint32{\underline}t *)s; s+=4;
                if( *option != '1' )
                    fprintf(fp,"{\percent}u ", n );
                    
                fprintf(fp,"{\percent}s{\backslash}n", s );
        {\rbrace}

        fclose(fp);
        leave: m{\underline}free{\underline}strings(args,0);
{\rbrace}\endCode


\Section
\Code
prog{\underline}parse({\dollar})
{\lbrace}

    if(! {\dollar}sln ) {\lbrace}
        prog{\underline}error({\dollar},"starting subshell with 'run'");
        prog{\underline}run({\dollar});
    {\rbrace}

    int from,len;

    from = 0;
    len  = m{\underline}len({\dollar}progm);

    /* get two integer args */
    char *s = (void*){\dollar}cmd+6;
    char *endp;
    from = strtol( s,{\ampersand}endp,10);
    if( s == endp ) {\lbrace} from=0; goto cont; {\rbrace}

 cont:
    prog{\underline}do{\underline}parse({\dollar}, from, len);
{\rbrace}\endCode


\Section
\Code
Bool  get{\underline}num(char ** s, int * num)
{\lbrace}
    while( **s {\ampersand}{\ampersand} isspace(**s) ) (*s)++;
    int n=0;
    char *e = *s;
    while( **s {\ampersand}{\ampersand} isdigit(**s) ) {\lbrace}
        n=(10*n) + (**s)-'0';
        (*s)++;
    {\rbrace}
    if( e == *s ) return 1;
    *num = n;
    return 0;
{\rbrace}\endCode


\Section
 delete lines from program
   example: 
   1) delete all
         del
   2) delete single line ten
         del 10
   3) delete five lines starting at ten
         del 10 5
   


\Code
prog{\underline}del({\dollar})
{\lbrace}
    char *s = (void*){\dollar}cmd+3;
    int from,cnt;
    
    if( get{\underline}num({\ampersand}s,{\ampersand}from) ) {\lbrace} m{\underline}free{\underline}strings( {\dollar}progm, 1); return; {\rbrace}
    if( get{\underline}num({\ampersand}s,{\ampersand}cnt) ) cnt=1;

    TRACE(1,"from:{\percent}d, cnt:{\percent}d", from, cnt );
    delete{\underline}lines({\dollar}, from, cnt );
{\rbrace}\endCode


\Section
 list program
   example: list 10
   example: list 10 8



\Code
prog{\underline}list({\dollar})
{\lbrace}
        int arg,from,len;

        from = 0;
        len  = 100;

        /* get two integer args */
        char *s = (void*){\dollar}cmd+5;
        char *endp;
        arg = strtol( s,{\ampersand}endp,10);
        if( s == endp ) {\lbrace} arg=0; goto cont; {\rbrace}

        s=endp; if( *s == ',' ) s++;
        from = arg;
        arg = strtol( s,{\ampersand}endp,10);
        if( s == endp ) {\lbrace} arg=0; goto cont; {\rbrace}
        len = arg;

        cont:
        te{\underline}pos1({\dollar}); te{\underline}down({\dollar});
        prog{\underline}do{\underline}list({\dollar}, from, len);
{\rbrace}\endCode


\Section
\Code
te{\underline}write({\dollar}, char * str)
{\lbrace}
    int len,l;
    unsigned char *string = (void*) str;
    uint32{\underline}t ucs4;
    len = strlen( (char*)string);

    while(1) {\lbrace}
        l = FcUtf8ToUcs4 (string, {\ampersand}ucs4, len);
        if( l{\langle}= 0 {\bar}{\bar} len {\langle}=0 ) return;
        te{\underline}putc({\dollar},ucs4);
        string += l;
        len -= l;
    {\rbrace}
{\rbrace}\endCode


\Section
\Code
te{\underline}writeln({\dollar}, char * s)
{\lbrace}
        te{\underline}write({\dollar},s);
        te{\underline}pos1({\dollar});
        te{\underline}down({\dollar});
{\rbrace}\endCode


\Section
\Code
prog{\underline}print({\dollar}, int  i)
{\lbrace}
        char buf[20];


        char *s = STR({\dollar}progm,i);
        uint32{\underline}t num = *(uint32{\underline}t *)s;
        s+=4;

        sprintf(buf,"{\percent}u", num);
        te{\underline}write({\dollar},buf);
        te{\underline}putc({\dollar},32);
        te{\underline}write({\dollar},s);
{\rbrace}\endCode


\Section
\Code
delete{\underline}lines({\dollar}, int  from, int  len)
{\lbrace}
        int i;
        int line;

        int match  = progm{\underline}find( {\dollar}progm, from, {\ampersand}line );
        if( match {\langle} 0 ) return;

        for(i=0;i{\langle}len;i++) {\lbrace}
                if( line {\rangle}= m{\underline}len({\dollar}progm) ) break;
                char *s = STR({\dollar}progm,line);             
                free(s);
                m{\underline}del({\dollar}progm,line);
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
prog{\underline}do{\underline}list({\dollar}, int  from, int  len)
{\lbrace}
        int i;
        int line;

        int match  = progm{\underline}find( {\dollar}progm, from, {\ampersand}line );
        if( match {\langle} 0 ) return;

        for(i=line;i{\langle}line+len;i++) {\lbrace}
                if( i {\rangle}= m{\underline}len({\dollar}progm) ) break;
                prog{\underline}print({\dollar},i);
                te{\underline}pos1({\dollar});
                te{\underline}down({\dollar});
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
prog{\underline}do{\underline}parse({\dollar}, int  from, int  len)
{\lbrace}
        int i;
        int line;

        int match  = progm{\underline}find( {\dollar}progm, from, {\ampersand}line );
        if( match {\langle} 0 ) return;

        for(i=line;i{\langle}line+len;i++) {\lbrace}
                if( i {\rangle}= m{\underline}len({\dollar}progm) ) break;
                char *s = STR({\dollar}progm,i);
                s+=4;
                
                /* dprintf( {\dollar}sln-{\rangle}fd[3], "{\percent}s{\backslash}n", s ); */
        {\rbrace}
{\rbrace}\endCode


\Section
 exit non-interactive mode



\Code
prog{\underline}exit({\dollar})
{\lbrace}
        {\dollar}INTERACTIVE=1;
        te{\underline}pos1({\dollar}); te{\underline}writeln({\dollar},"exit");
{\rbrace}\endCode


\Section
 kill child and exit non-interactive mode



\Code
prog{\underline}kill({\dollar})
{\lbrace}
        if(! sln{\underline}not{\underline}connected({\dollar}sln) ) {\lbrace}
             if( {\dollar}cid ) {\lbrace} XtRemoveInput({\dollar}cid); {\dollar}cid=0; {\rbrace}
             sln{\underline}close{\underline}fd({\dollar}sln);
        {\rbrace}
        prog{\underline}exit({\dollar});
{\rbrace}\endCode


\Section
\Code
do{\underline}resize({\dollar})
{\lbrace}
    {\dollar}scr=realloc({\dollar}scr, {\dollar}gWidth * {\dollar}gHeight * 4 );
    memset({\dollar}scr,0,{\dollar}gWidth * {\dollar}gHeight * 4 );
    {\dollar}cmd=realloc({\dollar}cmd,{\dollar}cmd{\underline}len = ({\dollar}gWidth+2) * 6 );
    TRACE(1,"WxH={\percent}dx{\percent}d{\backslash}n",{\dollar}gWidth, {\dollar}gHeight );
    TRACE(1,"pix WxH={\percent}dx{\percent}d{\backslash}n",{\dollar}grid{\underline}pix{\underline}width, {\dollar}grid{\underline}pix{\underline}height );
    TRACE(1,"w WxH={\percent}dx{\percent}d{\backslash}n",{\dollar}width, {\dollar}height );
{\rbrace}\endCode


\Section
\Code
int  xatoi(int  m, int * p, int * number{\underline}ret)
{\lbrace}
        while( *p {\langle} m{\underline}len(m) {\ampersand}{\ampersand} isspace(CHAR(m,*p))) (*p)++;
        
        int n=0;
        int e=*p;
        while( *p {\langle} m{\underline}len(m) {\ampersand}{\ampersand} isdigit(CHAR(m,*p))) {\lbrace}
               n=(n*10)+(CHAR(m,*p)-'0');
               (*p)++;
        {\rbrace}
        *number{\underline}ret = n;
        return e == *p;
{\rbrace}\endCode


\Section
\Code
int  parse{\underline}numbers(int  m, int * p, int  cnt)
{\lbrace}
        int num = m{\underline}create(10,sizeof(int));
        int d;

        while( xatoi(m,p,{\ampersand}d) == 0 {\ampersand}{\ampersand} cnt-- )
               m{\underline}put(num,{\ampersand}d);
              
        return num;
{\rbrace}\endCode


\Section
\Code
comm{\underline}gotoxy({\dollar}, int  buf)
{\lbrace}
        int offs = 7;
        int m = parse{\underline}numbers(buf,{\ampersand}offs, 2);
        if( m{\underline}len(m) !=2 ) {\lbrace}
            WARN("comm error");
            return;
        {\rbrace}
        te{\underline}gotoxy({\dollar}, INT(m,0), INT(m,1));
        m{\underline}free(m);
{\rbrace}\endCode


\Section
\Code
comm{\underline}err({\dollar}, int  buf)
{\lbrace}
        int offs = 4; /* err: */
        te{\underline}pos1({\dollar});
        if( offs {\langle} m{\underline}len(buf))
            te{\underline}write({\dollar}, mls(buf,offs) );
        te{\underline}pos1({\dollar});
        te{\underline}down({\dollar});
{\rbrace}\endCode


\Section
\Code
comm{\underline}write({\dollar}, int  buf)
{\lbrace}
        int offs = 6; /* write: */
        if( offs {\langle} m{\underline}len(buf))
            te{\underline}write({\dollar}, mls(buf,offs) );
{\rbrace}\endCode


\Section
\Code
void  parse{\underline}color({\dollar}, int  buf, int * p, XftColor * color{\underline}ret)
{\lbrace}
    Display *dpy;
    XRenderColor    renderColor;
    Screen      *screen;
    Colormap    colormap;
    int spec{\underline}m = m{\underline}create(20,1);
    
    screen = XtScreen({\dollar});
    dpy = XtDisplay({\dollar});
    colormap = DefaultColormap(dpy, DefaultScreen(dpy));
    
    while( *p {\langle} m{\underline}len(buf) {\ampersand}{\ampersand}
           isspace(CHAR(buf,*p))) (*p)++;
    while( *p {\langle} m{\underline}len(buf) {\ampersand}{\ampersand}
           !isspace(CHAR(buf,*p)))
        {\lbrace}
            m{\underline}putc(spec{\underline}m, CHAR(buf,*p));
            (*p)++;
        {\rbrace}
    m{\underline}putc(spec{\underline}m,0);

    char *spec = m{\underline}buf(spec{\underline}m);
    if (strcasecmp (spec, XtDefaultForeground) == 0)
        {\lbrace}
            renderColor.red = 0;
            renderColor.green = 0;
            renderColor.blue = 0;
            renderColor.alpha = 0xffff;
        {\rbrace}
    else if (strcasecmp (spec, XtDefaultBackground) == 0)
        {\lbrace}
            renderColor.red = 0xffff;
            renderColor.green = 0xffff;
            renderColor.blue = 0xffff;
            renderColor.alpha = 0xffff;
        {\rbrace}
    else if (!XRenderParseColor (dpy, spec, {\ampersand}renderColor))
        {\lbrace}

            goto parse{\underline}error;
        {\rbrace}

    if (XftColorAllocValue (dpy,
                             DefaultVisual (dpy,
                                            XScreenNumberOfScreen (screen)),
                             colormap,
                             {\ampersand}renderColor,
                             color{\underline}ret))
        {\lbrace}
            m{\underline}free(spec{\underline}m);
            return; /* success */
        {\rbrace}

    
 parse{\underline}error:
    WARN("error parsing color spec {\percent}s", spec );
    *color{\underline}ret =* ({\dollar}col[0]); /* default foreground, struct copy! */
    m{\underline}free(spec{\underline}m);
{\rbrace}\endCode


\Section
 draw filled rectangle
   example: rectf:10 20 30 40 white
   without color argument use default foreground color
   


\Code
comm{\underline}rectf({\dollar}, int  buf)
{\lbrace}
        int offs = 6;
        int m = parse{\underline}numbers(buf,{\ampersand}offs,4);
        if( m{\underline}len(m) !=4 ) {\lbrace}
            WARN("comm error");
            return;
        {\rbrace}

        XftColor col;
        parse{\underline}color( {\dollar}, buf, {\ampersand}offs, {\ampersand}col );

        XftDrawRect( {\dollar}draw, {\ampersand}col, 
                     INT(m,0), INT(m,1),
                     INT(m,2), INT(m,3) );
        m{\underline}free(m);
{\rbrace}\endCode


\Section
\Code
comm{\underline}clrscr({\dollar}, int  buf)
{\lbrace}
    te{\underline}clrscr({\dollar});
{\rbrace}\endCode


\Section
 draw circle
   example: CIRCLE:10 20 30 white
   without color argument use default foreground color
   


\Code
comm{\underline}circle({\dollar}, int  buf)
{\lbrace}
        int offs = 7;
        int m = parse{\underline}numbers(buf,{\ampersand}offs,3);
        if( m{\underline}len(m) !=3 ) {\lbrace}
            WARN("circle paramter error");
            return;
        {\rbrace}

        XftColor col;
        parse{\underline}color( {\dollar}, buf, {\ampersand}offs, {\ampersand}col );

        int x,y,r;
        x=INT(m,0);
        y=INT(m,1);
        r=INT(m,2);
        
        Display *dpy = XtDisplay({\dollar});
        Drawable d = XtWindow({\dollar});
        XSetForeground(dpy, {\dollar}gc{\underline}copy, col.pixel );
        XDrawArc( dpy, d, {\dollar}gc{\underline}copy, x,y,r,r,0,360*64 );    
        m{\underline}free(m);
{\rbrace}\endCode


\Section
 get screen size
   request: MEASURE_SCREEN
   reply:   MEASURE: width height columns rows 



\Code
comm{\underline}measure{\underline}screen({\dollar}, int  buf)
{\lbrace}
    sln{\underline}printf({\dollar}sln,"MEASURE{\underline}SCREEN:{\percent}d {\percent}d {\percent}d {\percent}d",
               {\dollar}width, {\dollar}height,
               {\dollar}gWidth, {\dollar}gHeight
               );
{\rbrace}\endCode


\Section
get event (keyboard or mouse)
  todo: falls das event zu alt ist
  kann es gelöscht werden
  die zeit kann mit der aktuellen systemzeit per:
  clock_gettime( CLOCK_MONOTONIC_COARSE, tp)
  verglichen werden
  


\Code
comm{\underline}poll({\dollar}, int  buf)
{\lbrace}
        termevent{\underline}t *te = mro{\underline}dequeue({\dollar}termevent{\underline}q);
        if( !te )
                sln{\underline}printf({\dollar}sln,"POLL:0 0 0 0");
        else     
                sln{\underline}printf({\dollar}sln,"POLL:{\percent}d {\percent}lu {\percent}lu {\percent}lu",
                   te-{\rangle}type, te-{\rangle}x, te-{\rangle}y, te-{\rangle}t );
{\rbrace}\endCode


\Section
 draw line
   example: LINE:10 20 100 30 white
   without color argument use default foreground color
   


\Code
comm{\underline}line({\dollar}, int  buf)
{\lbrace}
        int offs = 5;
        int m = parse{\underline}numbers(buf,{\ampersand}offs,4);
        if( m{\underline}len(m) !=4 ) {\lbrace}
            WARN("circle paramter error");
            return;
        {\rbrace}

        XftColor col;
        parse{\underline}color( {\dollar}, buf, {\ampersand}offs, {\ampersand}col );

        int x1,y1,x2,y2;
        x1=INT(m,0);
        y1=INT(m,1);
        x2=INT(m,2);
        y2=INT(m,3);    
        
        Display *dpy = XtDisplay({\dollar});
        Drawable d = XtWindow({\dollar});
        XSetForeground(dpy, {\dollar}gc{\underline}copy, col.pixel );
        XDrawLine( dpy, d, {\dollar}gc{\underline}copy, x1,y1,x2,y2 );    
        m{\underline}free(m);
{\rbrace}\endCode


\Section
\Code
comm{\underline}exit{\underline}cb({\dollar}, int  buf)
{\lbrace}
        TRACE(2,"exit");
        {\dollar}INTERACTIVE=1; 
        prog{\underline}exit({\dollar});
{\rbrace}\endCode


\Section
\Code
comm{\underline}run{\underline}cb({\dollar}, int  buf)
{\lbrace}
        TRACE(2,"run");
        {\dollar}INTERACTIVE=0;
{\rbrace}\endCode


\Section
\Code
comm{\underline}recv{\underline}cb(int  err, int  msg, int  sln, {\dollar})
{\lbrace}
    TRACE(2,"read line");       
    cp2{\underline}func{\underline}t func = cp2{\underline}lookup({\dollar}cp2,msg);
    if( func ) {\lbrace}
        func({\dollar}, (void*)(intptr{\underline}t)msg);
    {\rbrace} else WARN("command not found {\percent}s", (char*) m{\underline}buf(msg) );
{\rbrace}\endCode


\Section
 if we are not connected to a server create a connection
   this check is repeated every second



\Code
try{\underline}connect({\dollar}, XtIntervalId * id)
{\lbrace}
    XtAppContext app = XtWidgetToApplicationContext({\dollar});    
    if( sln{\underline}not{\underline}connected({\dollar}sln) ) {\lbrace}
        TRACE(1,"try connect to {\percent}s:{\percent}s",{\dollar}host,{\dollar}port); 
        int fd = sln{\underline}connect( {\dollar}sln, {\dollar}host,{\dollar}port, (sln{\underline}input{\underline}t)comm{\underline}recv{\underline}cb,  {\dollar});
        if( fd {\rangle}= 0 ) {\lbrace}
            {\dollar}cid = XtAppAddInput( app,
                           fd,
                           (XtPointer)XtInputReadMask,
                           (XtInputCallbackProc)prog{\underline}child{\underline}read,
                           {\dollar} );
        {\rbrace}
    {\rbrace}
    
    XtAppAddTimeOut(app , 1000,(XtTimerCallbackProc) try{\underline}connect, {\dollar} );
{\rbrace}\endCode


\Section
\Code
push{\underline}event({\dollar}, int  type, ulong  x, ulong  y, ulong  t)
{\lbrace}
        TRACE(1,"{\percent}d {\percent}ld {\percent}ld", type, x, y );
        termevent{\underline}t *ev = mro{\underline}alloc({\dollar}termevent{\underline}q);
        if( ev == 0 ) {\lbrace}
            mro{\underline}dequeue({\dollar}termevent{\underline}q);
            ev = mro{\underline}alloc({\dollar}termevent{\underline}q);
            if( ev == 0 )
                ERR("queue corrupted");
        {\rbrace}
        ev-{\rangle}type = type;
        ev-{\rangle}x = x;
        ev-{\rangle}y = y;
        ev-{\rangle}t = t;
{\rbrace}\endCode


\End\bye
