\input wbuildmac.tex
\Class{WpixBtn}einfaches Widget zur Anzeige verschiedener icons
  und funktion eines Buttons.
  {\tt pixmanNames} dateinamen der icons. Durch Komma od. Leerzeichen getrennt
  durch die resource {\tt value} werden die icons ausgewählt.
  ist kein icon vorhanden ist value negativ
  fg_norm,fg_sel,fg_hi wird für den rahmen verwendet
  bg_norm,bg_sel,bg_hi für den hintergrund




\Publicvars
\Table{WpixBtn}
XtNpixmapNames&XtCPixmapNames&String &NULL \cr
XtNvalue&XtCValue&int &0 \cr
XtNcornerRoundPercent&XtCCornerRoundPercent&int &0 \cr
XtNinnerBorderPercent&XtCInnerBorderPercent&int &0 \cr
XtNfileName&XtCFileName&String &NULL \cr
\endTable
\Section
\Publicvar{XtNpixmapNames}
String  pixmapNames = {\langle}String{\rangle}NULL 

\Section
\Publicvar{XtNvalue}
int  value = 0 

\Section
\Publicvar{XtNcornerRoundPercent}
int  cornerRoundPercent = 0 

\Section
\Publicvar{XtNinnerBorderPercent}
int  innerBorderPercent = 0 

\Section
\Publicvar{XtNfileName}
String  fileName = {\langle}String{\rangle}NULL 

\End\Table{Wheel}
XtNxftFont&XtCXFtFont&XftFont&"Sans-22"\cr
XtNcallback&XtCCallback&Callback&NULL \cr
XtNbg{\underline}norm&XtCBg{\underline}norm&Pixel&"lightblue"\cr
XtNbg{\underline}sel&XtCBg{\underline}sel&Pixel&"yellow"\cr
XtNbg{\underline}hi&XtCBg{\underline}hi&Pixel&"red"\cr
XtNfg{\underline}norm&XtCFg{\underline}norm&Pixel&"black"\cr
XtNfg{\underline}sel&XtCFg{\underline}sel&Pixel&"green"\cr
XtNfg{\underline}hi&XtCFg{\underline}hi&Pixel&"white"\cr
XtNuser{\underline}data&XtCUser{\underline}data&Int &0 \cr
XtNfocus{\underline}group&XtCFocus{\underline}group&String &""\cr
XtNstate&XtCState&Int &0 \cr
XtNregister{\underline}focus{\underline}group&XtCRegister{\underline}focus{\underline}group&Boolean &True \cr
\endTable
\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Translations
\Section
trans   <EnterWindow>: highlight()




\Section
trans   <LeaveWindow>: reset()


\Code
{\langle}BtnDown{\rangle}: notify() \endCode


\End\Actions
\Section
\Action{next{\underline}pixmap}\Code
void next{\underline}pixmap({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        int step=1;

        if( *num{\underline}params {\rangle} 0 )
            step = atoi( params[0] );
        {\dollar}value += step;
        if( {\dollar}value {\langle} 0 ) {\dollar}value=0;
        {\dollar}expose({\dollar},NULL,NULL);
{\rbrace}\endCode


\Section
\Action{highlight}\Code
void highlight({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
  if( {\dollar}state == STATE{\underline}SELECTED ) return;
  {\dollar}state = STATE{\underline}SELECTED;
  {\dollar}expose({\dollar},NULL,NULL);
{\rbrace}\endCode


\Section
\Action{reset}\Code
void reset({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
  if( {\dollar}state == STATE{\underline}NORMAL ) return;
  {\dollar}state = STATE{\underline}NORMAL;
  {\dollar}expose({\dollar},NULL,NULL);
{\rbrace}\endCode


\Section
\Action{notify}\Code
void notify({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
  XtCallCallbackList( {\dollar}, {\dollar}callback, event );
{\rbrace}\endCode


\End\Imports
\Section
\Code
{\incl} {\langle}X11/Xft/Xft.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/Xmu/Converters.h{\rangle}\endCode


\Section
\Code
{\incl} "converters.h"\endCode


\Section
\Code
{\incl} "xutil.h"\endCode


\Section
\Code
{\incl} "mls.h"\endCode


\End\Privatevars
\Section
\Code
struct {\lbrace}
  char *fileName;
  Pixmap map,mask;
  XRectangle pm{\underline}rect;
  int pm{\underline}depth; {\rbrace} pix{\underline}t\endCode


\Section
\Code
GC  pix{\underline}gc\endCode


\Section
\Code
int  m{\underline}pix\endCode


\Section
\Code
int  cur{\underline}pix\endCode


\Section
\Code
String  name{\underline}cache\endCode


\End\Methods
\Section
\Code
int  exec{\underline}command({\dollar}, int  cmd, int  val)
{\lbrace}
  Cardinal null;
  if( cmd == WHEEL{\underline}FIRE ) {\lbrace}
    if( {\dollar}state == STATE{\underline}SELECTED ) {\lbrace} notify({\dollar}, NULL,NULL, {\ampersand}null ); return 1; {\rbrace}
  {\rbrace}

  return 0;
{\rbrace}\endCode


\Section
\Code
class{\underline}initialize()
{\lbrace}
  m{\underline}init();
  converters{\underline}init();
{\rbrace}\endCode


\Section
\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}

  int           w,h;

  {\dollar}name{\underline}cache = 0;
  w=10; h=10;
  {\dollar}cur{\underline}pix = -1; /* pixmap cache, undefined */
  {\dollar}pix{\underline}gc=0;
  {\dollar}m{\underline}pix = m{\underline}create( 3, sizeof( pix{\underline}t ) );

  /* load all pixmaps and compute maximum width,height */
  parsePixmapNames({\dollar}, {\ampersand}w, {\ampersand}h);
  /* set size of this widget if not set already by geometry manager */
  if( {\dollar}width == 0 )  {\dollar}width   = increase{\underline}by{\underline}percent( w, {\dollar}innerBorderPercent );
  if( {\dollar}height == 0 ) {\dollar}height =  increase{\underline}by{\underline}percent( h, {\dollar}innerBorderPercent );

  /* if there are no pixmaps set {\bar}value{\bar} to -1 to indicate that there is */
  /* nothing to draw */
  if( m{\underline}len({\dollar}m{\underline}pix)==0 ) {\dollar}value = -1;
  compute{\underline}layout({\dollar});
{\rbrace}\endCode


\Section
\Code
realize({\dollar}, XtValueMask * mask, XSetWindowAttributes * attributes)
{\lbrace}
        XtCreateWindow({\dollar}, (unsigned int) InputOutput,
                          (Visual *) CopyFromParent, *mask, attributes);
        /* this gc is Not shared and its writeable */
        {\dollar}pix{\underline}gc    = XCreateGC(XtDisplay({\dollar}),XtWindow({\dollar}),0,NULL );
        reshape{\underline}widget({\dollar});
{\rbrace}\endCode


\Section
\Code
resize({\dollar})
{\lbrace}
    if (XtIsRealized({\dollar})) {\lbrace}
            {\dollar}cur{\underline}pix = -1;
            compute{\underline}layout({\dollar});
            reshape{\underline}widget({\dollar});
    {\rbrace}
{\rbrace}\endCode


\Section
\Code
destroy({\dollar})
{\lbrace}
  if( {\dollar}pix{\underline}gc ) XtReleaseGC({\dollar},{\dollar}pix{\underline}gc);
  unloadPixmaps({\dollar});
  if( {\dollar}name{\underline}cache ) free({\dollar}name{\underline}cache);
  m{\underline}free({\dollar}m{\underline}pix);
{\rbrace}\endCode


\Section
\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace}
  Display *dpy = XtDisplay({\dollar});
  if( !XtIsRealized({\dollar})) return;

  XSetWindowBorder( dpy, XtWindow({\dollar}), {\dollar}pixel[ {\dollar}state ] );
  XFillRectangle( dpy, XtWindow({\dollar}), {\dollar}gc[{\dollar}state], 0,0, {\dollar}width, {\dollar}height );

  /* check if we should display a pixmap */
  if( {\dollar}value {\langle} 0 {\bar}{\bar} m{\underline}len({\dollar}m{\underline}pix) == 0 ) return;

  /* check for overflow */
  if( {\dollar}value {\rangle}= m{\underline}len({\dollar}m{\underline}pix) ) {\dollar}value=0;

  /* check if we shall display a new pixmap and */
  /* need to apply a new pixmask */
  pix{\underline}t *p = mls({\dollar}m{\underline}pix, {\dollar}value);
  if( {\dollar}value != {\dollar}cur{\underline}pix ) {\lbrace}
    {\dollar}cur{\underline}pix = {\dollar}value;
    XSetClipMask(dpy, {\dollar}pix{\underline}gc,  p-{\rangle}mask);
    XSetClipOrigin(dpy, {\dollar}pix{\underline}gc, p-{\rangle}pm{\underline}rect.x, p-{\rangle}pm{\underline}rect.y );
  {\rbrace}

  /* display the image if it is not corrupted */
  if( p-{\rangle}pm{\underline}depth {\rangle} 0 ) {\lbrace}
    XCopyArea(dpy, p-{\rangle}map, XtWindow({\dollar}), {\dollar}pix{\underline}gc,
              0, 0, p-{\rangle}pm{\underline}rect.width, p-{\rangle}pm{\underline}rect.height,
              p-{\rangle}pm{\underline}rect.x, p-{\rangle}pm{\underline}rect.y );
     {\dollar}fileName = p-{\rangle}fileName;
  {\rbrace} else {\dollar}fileName = 0;
{\rbrace}\endCode


\Section
\Code
Boolean  set{\underline}values(Widget  old, Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
  Boolean redisplay = True;
  int w,h;

  /* user changes current pixmap */
  if( {\dollar}value != {\dollar}old{\dollar}value ) {\lbrace}
  {\rbrace};

  /* user changes pixmap cache */
  if( {\dollar}pixmapNames != {\dollar}old{\dollar}pixmapNames ) {\lbrace}
      {\dollar}cur{\underline}pix=0; /* expose needs to set a new clipmask */
      parsePixmapNames({\dollar},{\ampersand}w,{\ampersand}h);
      /* change widget size: only set width/height to a new value */
  {\rbrace}

  return redisplay;
{\rbrace}\endCode


\End\Utilities
\Section
\Code
unloadPixmaps({\dollar})
{\lbrace}
  int i; pix{\underline}t *p;
  m{\underline}foreach( {\dollar}m{\underline}pix, i, p ) {\lbrace}
             XFreePixmap( XtDisplay({\dollar}), p-{\rangle}map );
             XFreePixmap( XtDisplay({\dollar}), p-{\rangle}mask );
  {\rbrace}
  m{\underline}clear( {\dollar}m{\underline}pix ); /* set array size to zero */
{\rbrace}\endCode


\Section
parse the resource {\tt pixmapNames} and load pixmaps
  calculate maximum bounding box
  all curently loaded pixmaps are removed from memory


\Code
parsePixmapNames({\dollar}, int * wp, int * hp)
{\lbrace}
  pix{\underline}t         pix;
  char          *fn, *p;
  unloadPixmaps({\dollar});
  if(! {\dollar}pixmapNames  ) return;
  if(! *{\dollar}pixmapNames ) {\lbrace} {\dollar}pixmapNames=0; return; {\rbrace}

  if( {\dollar}name{\underline}cache ) free({\dollar}name{\underline}cache);
  {\dollar}name{\underline}cache = strdup({\dollar}pixmapNames); /* make sure we can modifiy memory */

  fn=p={\dollar}pixmapNames;
  *wp=*hp=0;
  while( (fn=xstrsep({\ampersand}p)) ) {\lbrace}
      if( !load{\underline}pix( {\dollar},fn, {\ampersand}pix ) ) {\lbrace}
        if( pix.pm{\underline}rect.width {\rangle}  *wp ) *wp=pix.pm{\underline}rect.width;
        if( pix.pm{\underline}rect.height {\rangle} *hp ) *hp=pix.pm{\underline}rect.height;
        m{\underline}put( {\dollar}m{\underline}pix, {\ampersand}pix );
      {\rbrace}
  {\rbrace}
{\rbrace}\endCode


\Section
\Code
compute{\underline}layout({\dollar})
{\lbrace}
  /* center images */
  int i;
  pix{\underline}t *p;
  m{\underline}foreach( {\dollar}m{\underline}pix, i, p ) {\lbrace}
    p-{\rangle}pm{\underline}rect.x = ({\dollar}width  - p-{\rangle}pm{\underline}rect.width) / 2;
    p-{\rangle}pm{\underline}rect.y = ({\dollar}height - p-{\rangle}pm{\underline}rect.height) / 2;

    TRACE(2,"{\percent}s ({\percent}dx{\percent}d+{\percent}d+{\percent}d)", p-{\rangle}fileName, p-{\rangle}pm{\underline}rect.width, p-{\rangle}pm{\underline}rect.height,
    p-{\rangle}pm{\underline}rect.x, p-{\rangle}pm{\underline}rect.y );
  {\rbrace}
{\rbrace}\endCode


\Section
suche das erste zeichen das kein leerzeichen und kein delimiter ist


\Code
int  skip(char ** p)
{\lbrace}
  char ch;
  if( p==0 {\bar}{\bar} *p==0 ) return -1;
  while(1) {\lbrace}
    ch = **p;
    if( ch == 0 ) return -1;
    if( ! isspace(ch) {\ampersand}{\ampersand} ch != ',' ) return 0;
    (*p)++;
  {\rbrace}
  return -1; /* never reached */
{\rbrace}\endCode


\Section
 fangt ab p an nach dem ersten
   nicht leeren und nicht delim zeichen zu suchen
   diese adresse wird zurückgegeben
   danach wird das ende dieses wortes gesucht
   dort wird ein null-byte gespeichert
   danach wird p auf den anfang des nächsten wortes gesetzt
   oder auf null.


\Code
char * xstrsep(char ** p)
{\lbrace}
  char ch;
  char *start;

  if( skip(p) ) return NULL;
  start = *p;

  while(1) {\lbrace}
    ch = **p;
    if( ch == 0 ) break;
    if( isspace(ch) {\bar}{\bar} ch == ',' ) {\lbrace}
      **p=0; (*p)++;
      break;
    {\rbrace}
    (*p)++;
  {\rbrace}
  return start;
{\rbrace}\endCode


\Section
load a pixmap. store information about pixmap in {\tt *p}.
  the filename ptr is stored too - but not a copy of that string.


\Code
int  load{\underline}pix({\dollar}, char * name, pix{\underline}t * p)
{\lbrace}
  Display *dpy = XtDisplay({\dollar});
  unsigned int width, height, bw, depth;
  Window win;
  int x,y;

  TRACE(2,"{\percent}s try loading {\percent}s{\backslash}n",{\dollar}name, name );

  if( load{\underline}pixmap{\underline}from{\underline}file({\dollar}, name, {\ampersand} p-{\rangle}map, {\ampersand} p-{\rangle}mask) )
    return -1;

  if (! XGetGeometry(dpy, p-{\rangle}map, {\ampersand}win, {\ampersand}x, {\ampersand}y, {\ampersand}width, {\ampersand}height, {\ampersand}bw, {\ampersand}depth))
    return -1;

  /* printf("loading success {\percent}s{\backslash}n", name ); */
  p-{\rangle}fileName = name;
  p-{\rangle}pm{\underline}rect.width  = (unsigned short) width;
  p-{\rangle}pm{\underline}rect.height = (unsigned short) height;
  p-{\rangle}pm{\underline}depth = depth;
  return 0;
{\rbrace}\endCode


\Section
\Code
reshape{\underline}widget({\dollar})
{\lbrace}
        int w;
        if( {\dollar}cornerRoundPercent {\rangle}0 {\ampersand}{\ampersand} {\dollar}cornerRoundPercent {\langle} 100 ) {\lbrace}
            w = Min({\dollar}height,{\dollar}width);
            w = w * {\dollar}cornerRoundPercent / 100;
            XmuReshapeWidget( {\dollar}, XmuShapeRoundedRectangle, w, w );
        {\rbrace}
{\rbrace}\endCode


\End\bye
