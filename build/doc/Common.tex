\input wbuildmac.tex
\Class{Common}The Common class is not meant to be instantiated. It only serves as
the common superclass for a family of widgets, to ensure that these
widgets have some common methods and resources.  The Common class
defines common types, symbolic constants, and type converters and it
also provides the basis for keyboard traversal.  The code for keyboard
traversal is roughly based on that in the Xw widget set (created by
Hewlett Packard), but it uses the {\tt accept{\underline}focus} method.

When the resource {\tt traversalOn} is set to {\tt True} (either at creation
time, or via a {\tt XtSetValues} later), a set of translations is added to
the widget. If the widget's parent is also a subclass of Common, these
translations will then implement keyboard traversal, using the cursor
keys (up, down, prev, etc.) Of course, when the widget already uses
these keys for other purposes, the keyboard traversal will not work.

The Common widget makes use of John Cwickla's X Color Context (XCC)
library, a system that makes it easier to select colors, since it
automatically uses standard colormaps where available and also rounds
requested colors to the nearest available one. For best results, an
application should create an XCC and pass it as a resource to Common
and its descendants, but Common will also create an XCC itself if none
is provided.



\Publicvars
\Table{Common}
XtNuseXCC&XtCUseXCC&Boolean &FALSE \cr
XtNusePrivateColormap&XtCUsePrivateColormap&Boolean &FALSE \cr
XtNuseStandardColormaps&XtCUseStandardColormaps&Boolean &TRUE \cr
XtNstandardColormap&XtCStandardColormap&Atom &0 \cr
XtNxcc&XtCXCc&XCC &create{\underline}xcc \cr
XtNtraversalOn&XtCTraversalOn&Boolean &True \cr
XtNhighlightThickness&XtCHighlightThickness&Dimension &2 \cr
XtNhighlightColor&XtCHighlightColor&Color &XtDefaultForeground \cr
XtNbackground&XtCBackground&Color &XtDefaultBackground \cr
XtNhighlightPixmap&XtCHighlightPixmap&Pixmap &None \cr
XtNnextTop&XtCNextTop&Callback&NULL \cr
XtNuserData&XtCUserData&Pointer&NULL \cr
\endTable
\Section
\Publicvar{XtNuseXCC}
By default, Common and all its subclasses use XCC's to control their
color allocations. But the use of XCC can be turned off. Some goodies,
like approximate colors instead of failures and use of standard
colormaps where available, will not be used, but the application may
start faster.

	

Boolean  useXCC = FALSE 

\Section
\Publicvar{XtNusePrivateColormap}
If {\tt usePrivateColormap} is {\tt TRUE} when the widget is created, it
will try to install a private colormap, from which all colors are
allocated. Changing this resource after the widget has been created
has no effect. (No effect if {\tt useXCC} is false.)

	

Boolean  usePrivateColormap = FALSE 

\Section
\Publicvar{XtNuseStandardColormaps}
{\tt useStandardColormaps} directs the widget to try to find an already
installed standard colormap. When the widget is created, it will look
for a list of standard colormap, both color and greyscale. It won't
create a new standard colormap itself. (No effect if {\tt useXCC} is
false.)

	 

Boolean  useStandardColormaps = TRUE 

\Section
\Publicvar{XtNstandardColormap}
Normally, when {\tt useStandardColormaps} is {\tt TRUE}, the widget will try
to find the best standard colormap from those that are installed on
the X server. You can force it to use a specific standard colormap by
setting {\tt standardColormap} to the Atom of that map. (No effect if
{\tt useXCC} is false.)

	

Atom  standardColormap = 0 

\Section
\Publicvar{XtNxcc}
{\tt xcc} holds the XCC descriptor, which is used when allocating colors
through {\tt XCCGetPixel}. Normally, the widget creates its own. (No
effect if {\tt useXCC} is false.)

	

XCC  xcc = {\langle}CallProc{\rangle}create{\underline}xcc 

\Section
\Publicvar{XtNtraversalOn}
The resource {\tt traversalOn} determines whether keyboard traversal is
used. If it is {\tt True} initially, or if it is set to {\tt True} later, a
set of translations will be added to the widget.

	

Boolean  traversalOn = True 

\Section
\Publicvar{XtNhighlightThickness}
Keyboard focus is indicated by border highlighting. When keyboard
traversal is on and the widget receives the focus, the highlight border
is filled with the highlight color or tile. If the widget does not
have the focus, the area is left in the default background.

	

Dimension  highlightThickness = 2 

\Section
\Publicvar{XtNhighlightColor}
The highlight border can have a color or it can be tiled with a
pixmap. Whichever of the resources {\tt highlightColor} or
{\tt highlightPixmap} is set latest, is used. When both are set, the
pixmap is used.

	

Color  highlightColor = {\langle}String{\rangle}XtDefaultForeground 

\Section
\Publicvar{XtNbackground}
In order to use the String to Color resource converter for the
background color as well, a new background resource is created,
conveniently called {\tt background}. The Core field {\tt background{\underline}pixel}
should not be used anymore.

	

Color  background = {\langle}String{\rangle}XtDefaultBackground 

\Section
\Publicvar{XtNhighlightPixmap}
The {\tt highlightPixmap} can be set to a pixmap with which the
highlight border will be tiled. Only one of {\tt highlightPixmap} and
{\tt highlightColor} can be set, see above.

	

Pixmap  highlightPixmap = None 

\Section
\Publicvar{XtNnextTop}
When an application has several top level windows, it should have a
way of setting the focus between windows. The Enter key in any widget
with keyboard traversal on normally invokes the {\tt traverseNextTop}
action, that will call the callbacks of the topmost Common (or
subclass) widget in the hierarchy. The callback may set the focus to
another top level widget, with {\tt XtCallAcceptFocus}.

	

{\langle}Callback{\rangle} XtCallbackList  nextTop = NULL 

\Section
\Publicvar{XtNuserData}
The resource {\tt userData} is provided for applications that want to
attach their own data to a widget. It is not used by the widget itself
in any way.

	

{\langle}Pointer{\rangle} XtPointer  userData = NULL 

\End\Table{Composite}
XtNchildren&XtCChildren&WidgetList &NULL \cr
insertPosition&XtCInsertPosition&XTOrderProc &NULL \cr
numChildren&XtCNumChildren&Cardinal &0 \cr
\endTable
\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Exports
\Section
The type {\tt Alignment} is actually an integer, but it is given a
different name to allow a type converter to be installed for it.

	

\Code
{\type} Alignment = int \endCode


\Section
The symbolic constants can be added together to form an alignment.
Various widgets use this to position labels, other widgets, etcetera.

	

\Macro
XfwfCenter = 0 \endMacro


\Section
\Macro
XfwfLeft = 1 \endMacro


\Section
\Macro
XfwfRight = 2 \endMacro


\Section
\Macro
XfwfTop = 4 \endMacro


\Section
\Macro
XfwfBottom = 8 \endMacro


\Section
For convenience, the eight possible combinations also have symbolic
names.

	

\Macro
XfwfTopLeft = (XfwfTop +XfwfLeft )\endMacro


\Section
\Macro
XfwfTopRight = (XfwfTop +XfwfRight )\endMacro


\Section
\Macro
XfwfBottomLeft = (XfwfBottom +XfwfLeft )\endMacro


\Section
\Macro
XfwfBottomRight = (XfwfBottom +XfwfRight )\endMacro


\Section
The directions of traversal are used as arguments to the {\tt traverse}
method. They are probably only useful to subclasses.

	

\Code
{\type} TraversalDirection = enum {\lbrace}
            TraverseLeft, TraverseRight, TraverseUp, TraverseDown,
            TraverseNext, TraversePrev, TraverseHome, TraverseNextTop {\rbrace}\endCode


\Section
The {\tt Color} type is an alias for {\tt Pixel}, so that a new resource
converter can be installed.

	

\Code
{\type} Color = Pixel \endCode


\Section
To know the inside area of a Common widget might be useful to other
widgets than subclasses alone. Calling {\tt XfwfCallComputeInside} will
call the {\tt compute{\underline}inside} method, if available.



\Code
XfwfCallComputeInside( {\dollar}, Position * x, Position * y, Dimension * w, Dimension * h)\endCode
{\lbrace}
    if (XtIsSubclass({\dollar}, commonWidgetClass) {\ampersand}{\ampersand} {\dollar}compute{\underline}inside)
        {\dollar}compute{\underline}inside({\dollar}, x, y, w, h);
    else 
        XtWarning
            ("XfwfCallComputeInside only applies to subclasses of Common");
{\rbrace}

\Section
Another convenience function is {\tt XfwfCallFrameWidth}, which uses the
method {\tt total{\underline}frame{\underline}width} to compute the thickness of the frame that
the widget will draw.



\Code
Dimension  XfwfCallFrameWidth( {\dollar})\endCode
{\lbrace}
    if (XtIsSubclass({\dollar}, commonWidgetClass) {\ampersand}{\ampersand} {\dollar}total{\underline}frame{\underline}width)
        return {\dollar}total{\underline}frame{\underline}width({\dollar});
    else 
        XtWarning
            ("XfwfCallFrameWidth only applies to subclasses of Common");
    return 0;
{\rbrace}

\Section
All subclasses need to know the {\tt XCC} type.


\Code
{\incl} "XCC.h"\endCode


\End\Actions
\Section
When the widget receives or looses the focus, the border highlight
is drawn or removed. This action function draws the highlight border
and in case the widget has set {\tt traversalOn}, it also sets the
keyboard focus to the widget itself, or one of its children.

However, FocusIn events may also be so-called virtual events, meaning
that not the receiving widget, but one of its descendants gets the
real focus. When {\tt focusIn} receives one of those, it removes the
highlight border.



\Macro
focus{\underline}detail(detail) =
(detail ==NotifyAncestor ?"NotifyAncestor":detail ==NotifyVirtual ?"NotifyVirtual":detail ==NotifyInferior ?"NotifyInferior":detail ==NotifyNonlinear ?"NotifyNonlinear":detail ==NotifyNonlinearVirtual ?"NotifyNonlinearVirtual":detail ==NotifyPointer ?"NotifyPointer":detail ==NotifyPointerRoot ?"NotifyPointerRoot":detail ==NotifyDetailNone ?"NotifyDetailNone":"???")\endMacro


\Section
\Action{focusIn}\Code
void focusIn({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    Time time = CurrentTime;

    if (event-{\rangle}type != FocusIn)
        XtError("focusIn action may only be bound to FocusIn events");
    if (! {\dollar}traversalOn)
        return;
    if (event-{\rangle}xfocus.detail == NotifyAncestor
        {\bar}{\bar} event-{\rangle}xfocus.detail == NotifyInferior
        {\bar}{\bar} event-{\rangle}xfocus.detail == NotifyNonlinear) {\lbrace}
        if (! {\dollar}traversal{\underline}focus) (void) {\dollar}accept{\underline}focus({\dollar}, {\ampersand}time);
    {\rbrace} else if ({\dollar}traversal{\underline}focus) {\lbrace}
        {\dollar}unhighlight{\underline}border({\dollar});
        {\dollar}traversal{\underline}focus = False;
    {\rbrace}
{\rbrace}\endCode


\Section
\Action{focusOut}This action removes the highlight border.



\Code
void focusOut({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    if (event-{\rangle}type != FocusOut)
        XtError("focusOut action may only be bound to FocusOut events");
    if ({\dollar}traversal{\underline}focus) {\lbrace}
        {\dollar}unhighlight{\underline}border({\dollar});
        {\dollar}traversal{\underline}focus = False;
    {\rbrace}
{\rbrace}\endCode


\Section
\Action{traverseDown}This and the following actions all call the {\tt traverse} method of the
widget's parent, with the appropiate direction arguments.
{\tt traverseDown} tries to set the focus to a widget that is located
roughly below the current one.



\Code
void traverseDown({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseDown, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseUp}The action tries to set the focus to a widget that is above the this
one.



\Code
void traverseUp({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseUp, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseLeft}{\tt traverseLeft} looks for a widget to the left of the current one and
sets the keyboard focus to that.



\Code
void traverseLeft({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseLeft, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseRight}The action looks for a widget that will aceept the focus to the
right of the current one.



\Code
void traverseRight({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseRight, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseNext}The next sibling gets the focus. The precise order is determined by
the parent, but usually is will be the order in which the widgets were
created. If there is no suitable sibling, the request is passed to the
grandparent, so that an `aunt widget' or other relation can get the
focus.



\Code
void traverseNext({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseNext, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traversePrev}The previous widget gets the focus. See also the description of
{\tt traverseNext} above.



\Code
void traversePrev({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraversePrev, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseNextTop}{\tt traverseNextTop} finds the topmost ancestor that is a subclass of
Common and lets it call the {\tt nextTop} callbacks that have been
registered there. These callbacks can be used by an application that
has multiple top level windows to set the focus to another window.



\Code
void traverseNextTop({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseNextTop, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseHome}The action sets the focus to the sibling widget that is closest to
the upper left corner of the parent.



\Code
void traverseHome({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    {\dollar}traverse({\dollar}, TraverseHome, {\dollar}, {\ampersand}event-{\rangle}xkey.time);
{\rbrace}\endCode


\Section
\Action{traverseCurrent}The {\tt traverseCurrent} action can be used by widgets to set the focus
to themselves. It is not used in the set of translations that is added
when {\tt traversalOn} is set to {\tt True}.



\Code
void traverseCurrent({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
    Time time = CurrentTime;

    if ({\dollar}traversalOn) (void) {\dollar}accept{\underline}focus({\dollar}, {\ampersand}time);
{\rbrace}\endCode


\End\Imports
\Section
\Code
{\incl} {\langle}ctype.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}stdio.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}assert.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/Xmu/Converters.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/Xmu/CharSet.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/ShellP.h{\rangle}\endCode


\Section
\Code
{\incl} "converters.h"\endCode


\End\Privatevars
\Section
{\tt abs}, {\tt min} and {\tt max} are used often enough in various subclasses
to define them here. They will end up in the private(!) header file.

	

\Code
 max\endCode


\Section
\Code
 min\endCode


\Section
\Code
 abs\endCode


\Section
A private variable is used to track the keyboard focus, but only
while traversal is on. If {\tt traversal{\underline}focus} is {\tt True}, it means that
the widget has keyboard focus and that that focus is a result of
keyboard traversal. It also means that the widget's border is
highlighted, although that is only visible if the {\tt highlightThickness}
is positive.

	

\Code
Bool  traversal{\underline}focus\endCode


\Section
The highlight border is filled with a color or a tile.

	

\Code
GC  bordergc\endCode


\Section
When the {\tt xcc} is created by the widget itself, it must also be
destroyed again.

	  

\Code
Bool  own{\underline}xcc\endCode


\End\Classvars
\Section
{\tt traversal{\underline}trans} holds the compiled version of the
{\tt extraTranslations}.

	

\Code
XtTranslations  traversal{\underline}trans = NULL \endCode


\Section
Set a few class variables.

	

\Code
compress{\underline}motion = True \endCode


\Section
\Code
compress{\underline}exposure = XtExposeCompressMultiple \endCode


\Section
\Code
compress{\underline}enterleave = True \endCode


\Section
The {\tt visible{\underline}interest} field is set to {\tt TRUE}, because we need
the {\tt visible} field to check if it is OK to set the focus.

	

\Code
visible{\underline}interest = TRUE \endCode


\End\Methods
\Section
The type converter {\tt cvtStringToAlignment} is installed in the
{\tt class{\underline}initialize} method, after the quarks for the recognized strings
are created.

The converter from String to Icon needs one extra argument, viz., the
widget for which the icon is loaded. An offset of 0 should give a
pointer to the widget itself.



\Code
class{\underline}initialize()
{\lbrace}
{\hashmark}ifndef NO{\underline}XPM
    static XtConvertArgRec args[] = {\lbrace}
        {\lbrace} XtWidgetBaseOffset,
          0,
          sizeof(Widget) {\rbrace},
        {\lbrace} XtWidgetBaseOffset,
          (XtPointer) XtOffsetOf(CommonRec, core.colormap),
          sizeof(Colormap) {\rbrace},
        {\lbrace} XtWidgetBaseOffset,
          (XtPointer) XtOffsetOf(CommonRec, common.xcc),
          sizeof(XCC) {\rbrace} {\rbrace};
{\hashmark}endif
    static XtConvertArgRec colorargs[] = {\lbrace}
        {\lbrace} XtWidgetBaseOffset,
          (XtPointer) XtOffsetOf(CommonRec, core.colormap),
          sizeof(Colormap) {\rbrace},
        {\lbrace} XtWidgetBaseOffset,
          (XtPointer) XtOffsetOf(CommonRec, common.xcc),
          sizeof(XCC) {\rbrace} {\rbrace};

    XtSetTypeConverter(XtRString, "Alignment", cvtStringToAlignment,
                       NULL, 0, XtCacheNone, NULL);
    XtSetTypeConverter("Alignment", XtRString, cvtAlignmentToString,
                       NULL, 0, XtCacheNone, NULL);
    /* init{\underline}icon{\underline}quarks(); */
{\hashmark}ifndef NO{\underline}XPM
    XtSetTypeConverter(XtRString, "Icon", cvtStringToIcon,
                       args, XtNumber(args), XtCacheByDisplay,
                       cvtIconDestructor);
{\hashmark}endif
    XtSetTypeConverter(XtRString, "StringArray", cvtStringToStringArray,
                       NULL, 0, XtCacheNone, NULL);
    XtSetTypeConverter(XtRString, XtRColor, cvtStringToColor,
                       colorargs, XtNumber(colorargs), XtCacheNone, NULL);
{\rbrace}\endCode


\Section
The {\tt extraTranslations} are compiled into Xt's internal form and
stored in a class variable {\tt traversal{\underline}trans}, but only if that hasn't
been done before. (It should have been done in the {\tt class{\underline}initialize}
method, but wbuild's `{\tt {\dollar}}' syntax doesn't work there (yet)).

If the widget has the {\tt traversalOn} resource set, the translations are
merged with the widgets existing translations.



\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
    Dimension frame;

    if ({\dollar}traversal{\underline}trans == NULL)
        {\dollar}traversal{\underline}trans = XtParseTranslationTable(extraTranslations);
    if ({\dollar}traversalOn) {\lbrace}
        XtAugmentTranslations({\dollar}, {\dollar}traversal{\underline}trans);
        {\dollar}visible{\underline}interest = True;
    {\rbrace}
    {\dollar}traversal{\underline}focus = FALSE;
    {\dollar}bordergc = NULL;
    frame = {\dollar}total{\underline}frame{\underline}width({\dollar});
    if ({\dollar}width {\langle} 2 * frame + 2) {\dollar}width = 2 * frame + 2;
    if ({\dollar}height {\langle} 2 * frame + 2) {\dollar}height = 2 * frame + 2;
    if ({\dollar}width == 0) {\dollar}width = 2;
    if ({\dollar}height == 0) {\dollar}height = 2;
    create{\underline}bordergc({\dollar});
    {\dollar}background{\underline}pixel = {\dollar}background;
    {\dollar}visible = FALSE;                           /* Why is this needed? */
    /* fprintf(stderr, "initialize({\percent}s): visible={\percent}s{\backslash}n",
       XtName({\dollar}), {\dollar}visible?"TRUE":"FALSE"); */
{\rbrace}\endCode


\Section
The {\tt set{\underline}values} method checks if the keyboard traversal has been
turned on and adds the traversal translations. (It can only be turned
on, not turned off.)

If something changes that causes the widget to loose keyboard focus,
the parent is asked to put the focus somewhere else. Otherwise the
whole application might suddenly loose keyboard focus.



\Code
Boolean  set{\underline}values(Widget  old, Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
    Boolean need{\underline}redraw = False;
    Widget parent = XtParent({\dollar});
    Time time = CurrentTime;

    if ({\dollar}traversalOn != {\dollar}old{\dollar}traversalOn {\ampersand}{\ampersand} {\dollar}traversalOn) {\lbrace}
        XtAugmentTranslations({\dollar}, {\dollar}traversal{\underline}trans); 
        {\dollar}visible{\underline}interest = True;
    {\rbrace}
    if (({\dollar}sensitive != {\dollar}old{\dollar}sensitive
         {\bar}{\bar} {\dollar}ancestor{\underline}sensitive != {\dollar}old{\dollar}ancestor{\underline}sensitive
         {\bar}{\bar} {\dollar}traversalOn != {\dollar}old{\dollar}traversalOn)
        {\ampersand}{\ampersand} {\dollar}traversal{\underline}focus) {\lbrace}
        if (XtIsSubclass(parent, commonWidgetClass)) {\lbrace}
            if (!{\dollar}sensitive) {\lbrace}
                /*
                 * Necessary when {\dollar} is highlighted and {\dollar}sensitive is
                 * changed to FALSE. When this is left out keyboard
                 * traversal doesn't work when {\dollar}sensitive is changed back
                 * to TRUE.
                 */
                {\dollar}unhighlight{\underline}border({\dollar});
                {\dollar}traversal{\underline}focus = FALSE;
            {\rbrace}
            {\dollar}parent{\dollar}traverse(parent, TraverseHome, {\dollar}, {\ampersand}time);
        {\rbrace}
    {\rbrace}
    if ({\dollar}highlightThickness != {\dollar}old{\dollar}highlightThickness)
        need{\underline}redraw = True;
    if ({\dollar}highlightPixmap != {\dollar}old{\dollar}highlightPixmap) {\lbrace}
        create{\underline}bordergc({\dollar});
        need{\underline}redraw = True;
    {\rbrace} else if ({\dollar}highlightColor != {\dollar}old{\dollar}highlightColor) {\lbrace}
        {\dollar}highlightPixmap = None;
        create{\underline}bordergc({\dollar});
        need{\underline}redraw = True;
    {\rbrace}
    if ({\dollar}background != {\dollar}old{\dollar}background) {\lbrace}
        {\dollar}background{\underline}pixel = {\dollar}background;
        need{\underline}redraw = True;
    {\rbrace}
    return need{\underline}redraw;
{\rbrace}\endCode


\Section
A new method {\tt compute{\underline}inside} is defined, that returns the area
inside the highlight border. Subclasses should use this to compute
their drawable area, in preference to computing it from {\tt {\dollar}width} and
{\tt {\dollar}height}. Subclasses, such as the Frame widget, redefine the method
if they add more border material.



\Code
compute{\underline}inside({\dollar}, Position * x, Position * y, Dimension * w, Dimension * h)
{\lbrace}
    *x = {\dollar}highlightThickness;
    *y = {\dollar}highlightThickness;
    *w = {\dollar}width - 2 * {\dollar}highlightThickness;
    *h = {\dollar}height - 2 * {\dollar}highlightThickness;
{\rbrace}\endCode


\Section
Another new method, {\tt total{\underline}frame{\underline}width}, returns the thickness of
the frame that will be drawn onside the widget. Subclasses will need
to override this method if they draw other frames.



\Code
Dimension  total{\underline}frame{\underline}width({\dollar})
{\lbrace}
    return {\dollar}highlightThickness;
{\rbrace}\endCode


\Section
The {\tt expose} method draws the highlight border, if there is one.



\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace}
    if (! XtIsRealized({\dollar})) return;
    if (region != NULL) XSetRegion(XtDisplay({\dollar}), {\dollar}bordergc, region);
    if ({\dollar}traversal{\underline}focus) {\dollar}highlight{\underline}border({\dollar});
    if (region != NULL) XSetClipMask(XtDisplay({\dollar}), {\dollar}bordergc, None);
{\rbrace}\endCode


\Section
When the widget is destroyed and the widget still has the keyboard
focus, the parent is asked to give it to another widget.



\Code
destroy({\dollar})
{\lbrace}
    Widget parent = XtParent({\dollar});
    Time time = CurrentTime;

    if ({\dollar}traversal{\underline}focus) {\lbrace}
        {\dollar}sensitive = False;
        if (XtIsSubclass(parent, commonWidgetClass))
            {\dollar}parent{\dollar}traverse(parent, TraverseHome, {\dollar}, {\ampersand}time);
    {\rbrace}
    if ({\dollar}own{\underline}xcc) XCCFree({\dollar}xcc);
{\rbrace}\endCode


\Section
\Code
realize({\dollar}, XtValueMask * mask, XSetWindowAttributes * attributes)
{\lbrace}
    Widget p;

    {\hashmark}realize({\dollar}, mask, attributes);
    p = {\dollar};
    do p = XtParent(p); while (!XtIsShell(p));
    if ({\dollar}useXCC {\ampersand}{\ampersand} XCCGetColormap({\dollar}xcc) != {\dollar}p{\dollar}colormap)
        XtVaSetValues(p, XtNcolormap, XCCGetColormap({\dollar}xcc), NULL);
{\rbrace}\endCode


\Section
The border highlight is drawn and removed with two methods, although
few subclasses will want to redefine them. The methods are called by
the {\tt focusIn} and {\tt focusOut} actions and {\tt highlight{\underline}border} is also
called by {\tt expose}.



\Code
highlight{\underline}border({\dollar})
{\lbrace}
    XRectangle rect[4];

    if ({\dollar}highlightThickness == 0) return;

    rect[0].x = 0;
    rect[0].y = 0;
    rect[0].width = {\dollar}width;
    rect[0].height = {\dollar}highlightThickness;

    rect[1].x = 0;
    rect[1].y = 0;
    rect[1].width = {\dollar}highlightThickness;
    rect[1].height = {\dollar}height;

    rect[2].x = {\dollar}width - {\dollar}highlightThickness;
    rect[2].y = 0;
    rect[2].width = {\dollar}highlightThickness;
    rect[2].height = {\dollar}height;

    rect[3].x = 0;
    rect[3].y = {\dollar}height - {\dollar}highlightThickness;
    rect[3].width = {\dollar}width;
    rect[3].height = {\dollar}highlightThickness;

    XFillRectangles(XtDisplay({\dollar}), XtWindow({\dollar}), {\dollar}bordergc, {\ampersand}rect[0], 4);
{\rbrace}\endCode


\Section
\Code
unhighlight{\underline}border({\dollar})
{\lbrace}
    if ({\dollar}highlightThickness == 0) return;

    XClearArea(XtDisplay({\dollar}), XtWindow({\dollar}), 
               0, 0, {\dollar}width, {\dollar}highlightThickness, False);
    XClearArea(XtDisplay({\dollar}), XtWindow({\dollar}),
               0, 0, {\dollar}highlightThickness, {\dollar}height, False);
    XClearArea(XtDisplay({\dollar}), XtWindow({\dollar}),
               {\dollar}width - {\dollar}highlightThickness, 0, 
               {\dollar}highlightThickness, {\dollar}height, False);
    XClearArea(XtDisplay({\dollar}), XtWindow({\dollar}),
               0, {\dollar}height - {\dollar}highlightThickness,
               {\dollar}width, {\dollar}highlightThickness, False);
{\rbrace}\endCode


\Section
When the {\tt accept{\underline}focus} method is called, the widget should try to set
the focus to itself or one of its children. If it succeeds, it returns
{\tt True} else {\tt False}. If there are children, each is asked in turn,
until one is found that accepts the focus. If none is found, the
widget checks it's own {\tt sensitive} resource, to see if it can receive
keyboard events. If so, it sets the focus to itself and returns
{\tt True}, otherwise {\tt False}.



\Code
Boolean  accept{\underline}focus({\dollar}, Time * time)
{\lbrace}
    int i;

    /* fprintf(stderr, "accept{\underline}focus({\percent}s): visible={\percent}s{\backslash}n",
       XtName({\dollar}), {\dollar}visible?"TRUE":"FALSE"); */
    if (! XtIsRealized({\dollar}) {\bar}{\bar} ! XtIsSensitive({\dollar}) {\bar}{\bar} ! {\dollar}traversalOn
        {\bar}{\bar} ! {\dollar}visible {\bar}{\bar} ! {\dollar}ancestor{\underline}sensitive {\bar}{\bar} {\dollar}being{\underline}destroyed)
        return FALSE;
    for (i = 0; i {\langle} {\dollar}num{\underline}children; i++)
        if (XtCallAcceptFocus({\dollar}children[i], time)) return TRUE;
    if (! {\dollar}traversal{\underline}focus) {\lbrace}
        XSetInputFocus(XtDisplay({\dollar}), XtWindow({\dollar}), RevertToParent, *time);
        {\dollar}traversal{\underline}focus = True;
        {\dollar}highlight{\underline}border({\dollar});
    {\rbrace}
    return TRUE;
{\rbrace}\endCode


\Section
A Common widget (and most subclasses) return {\tt True} for
{\tt would{\underline}accept{\underline}focus}, if the {\tt sensitive}, {\tt visible} and {\tt traversalOn}
resources are set and none of the children wants the focus.



\Code
Boolean  would{\underline}accept{\underline}focus({\dollar})
{\lbrace}
    int i;
    Widget child;

    if (! XtIsRealized({\dollar}) {\bar}{\bar} ! XtIsSensitive({\dollar}) {\bar}{\bar} ! {\dollar}traversalOn
        {\bar}{\bar} ! {\dollar}visible {\bar}{\bar} ! {\dollar}ancestor{\underline}sensitive {\bar}{\bar} {\dollar}being{\underline}destroyed)
        return FALSE;
    else {\lbrace}
        for (i = 0; i {\langle} {\dollar}num{\underline}children; i++) {\lbrace}
            child = {\dollar}children[i];
            if (XtIsSubclass(child, commonWidgetClass)
                {\ampersand}{\ampersand} {\dollar}child{\dollar}would{\underline}accept{\underline}focus(child))
                return FALSE;
        {\rbrace}
        return TRUE;
    {\rbrace}
{\rbrace}\endCode


\Section
The algorithm behind keyboard traversal





\Section


\Section
* Handling focus events

If a widget receives a (non-virtual) FocusIn event, this is usually
caused by the {\tt accept{\underline}focus} method of that widget, except in the case
that a top level widget receives the focus from the window manager. In
the first case, the window can just draw the highlight border, in the
second case, the widget should try to set the focus to one of its
children.

To be able to distinguish the two cases, the {\tt accept{\underline}focus} method
sets the private instance variable {\tt traversal{\underline}focus} to {\tt True} before
it calls {\tt XSetInputFocus}. The {\tt focusIn} action then checks this
variable and if it is not set, calls the {\tt accept{\underline}focus} method.

The {\tt focusOut} action resets {\tt traversal{\underline}focus} to {\tt False}.

The {\tt traversal{\underline}focus} variable can be interpreted to mean, that the
widget has the keyboard focus and that it is because of keyboard
traversal. At least in the Common widget, it can never be {\tt True} when
{\tt traversalOn} is not set. It can also only be {\tt True} when the widget
actually has the focus, except in the short time between the
{\tt XSetInputFocus} call and the delivery of the {\tt FocusIn} event.
(However, this scheme depends on the {\tt focusOut} action for resetting
{\tt traversal{\underline}focus} to {\tt False}, so, if the translation for the
{\tt FocusOut} event is overridden, it will break down.)





\Section


\Section
* User events

The {\tt traverseXXX} actions can be bound to keyboard events. They call
the {\tt traverse} method, which will try to change the focus in the
indicated direction. The directions are: Home, Up, Left, Down, Right,
Next, Prev.  Each direction can be considered a constraint or
criterium for choosing the focus widget, e.g., `Up' selects the
nearest widget that is above the current widget. `Next' and `Prev' are
simpler, in that they do not check the distance, but only the order in
the list of children.

The {\tt traverseCurrent} action is different. It is usually bound to a
mouse click and its task is to set the focus to the widget itself. It
does this by calling {\tt accept{\underline}focus} on itself.

The {\tt traverse} method looks for a widget in the indicated direction,
within the same application. If the direction is not `Next' or `Prev',
the method first recurses upwards, to the toplevel widget. From there
it recurses down again, to all children, grandchildren, etc., looking
for the widget that best matches the criterium. If a widget is found,
the focus will be set to it with a call to {\tt XSetInputFocus}. The
private variable {\tt traversal{\underline}focus} will be set to {\tt True} to indicate
that the widget received the focus as a result of keyboard traversal,
and not from the window manager or any other source.

If the {\tt direction} argument is `Next' or `Prev', {\tt traverse} will try
to set the focus to a sister widget, using the {\tt accept{\underline}focus} method.
If there is no suitable sister, the parent will be asked to find an
aunt widget, and so on.

Note that the {\tt traverse} and {\tt accept{\underline}focus} methods of the Common
widget only set the focus to a child, if the widget itself has
{\tt traversalOn}.  Thus, setting {\tt traversalOn} to {\tt False} for a certain
widget not only excludes the widget itself from keyboard traversal,
but also all its children.

The {\tt traverse} function is a method and not a utility function,
because it is expected that a few subclasses may want to redefine it.
E.g., the (not yet existing) Group widget may want to limit traversal
to widgets within itself. (And presumably define new actions to jump
outside the group.)

To check if a widget suits the criterium, two things must be
determined: is the widget eligible for the focus and what is the
distance between the widget and the target position. To be able to
determine if the widget can accept the focus without actually setting
it, a method {\tt would{\underline}accept{\underline}focus} is defined, that returns {\tt True} if
the widget is willing to set the focus to itself.





\Section


\Section
If the {\tt dir} argument to {\tt traverse} is {\tt TraverseNext} or
{\tt TraversePrev}, the {\tt traverse{\underline}to{\underline}next} or {\tt traverse{\underline}to{\underline}prev} utility
functions are called.  Otherwise, the {\tt traverse} method checks the
class of the parent. If the parent is a subclass of {\tt Common}, it
also has a {\tt traverse} method and the task of finding a widget to
traverse to is delegated to the parent. Otherwise, the desired widget
is looked for with the help of a utility function.

The {\tt dir} argument is one of Home, Up, Down, Left, Right, Next or
Prev.  The {\tt current} argument holds the widget that currently has the
focus and relative to which the focus will have to move.



\Macro
LARGE{\underline}NUMBER = 2000000000 \endMacro


\Section
\Code
traverse({\dollar}, TraversalDirection  dir, Widget  current, Time * time)
{\lbrace}
    Widget w, parent = XtParent({\dollar});
    Position x, y;
    int distance = LARGE{\underline}NUMBER;

    if (dir == TraverseNextTop)
        traverse{\underline}to{\underline}next{\underline}top({\dollar}, current, time);
    else if (dir == TraverseNext)
        traverse{\underline}to{\underline}next({\dollar}, current, time);
    else if (dir == TraversePrev)
        traverse{\underline}to{\underline}prev({\dollar}, current, time);
    else if (XtIsSubclass(parent, commonWidgetClass))
        {\dollar}parent{\dollar}traverse(parent, dir, current, time);
    else {\lbrace}
        if ({\dollar}being{\underline}destroyed) return;                    /* LW, 951114 */
        switch (dir) {\lbrace}
        case TraverseHome: x = 0; y = 0; break;
        case TraverseLeft: x = 0; y = {\dollar}current{\dollar}height/2; break;
        case TraverseDown: x = {\dollar}current{\dollar}width/2; y = {\dollar}current{\dollar}height; break;
        case TraverseRight: x = {\dollar}current{\dollar}width; y = {\dollar}current{\dollar}height/2; break;
        case TraverseUp: x = {\dollar}current{\dollar}width/2; y = 0; break;
    case TraverseNext:
    case TraversePrev:
    case TraverseNextTop:   
    default: break;
        {\rbrace}
        if (dir != TraverseHome) XtTranslateCoords(current, x, y, {\ampersand}x, {\ampersand}y);
        if (traverse{\underline}to{\underline}direction({\dollar}, dir, x, y, {\ampersand}w, {\ampersand}distance))
            XtCallAcceptFocus(w, time);
    {\rbrace}
{\rbrace}\endCode


\Section
The method {\tt lighter{\underline}color} uses {\tt choose{\underline}color} to compute a color
that is 1.35 times as bright as the color passed in as argument. The
function result is {\tt True} if a color was allocated, else {\tt False}.



\Code
Boolean  lighter{\underline}color({\dollar}, Pixel  base, Pixel * result)
{\lbrace}
    if (! {\dollar}useXCC) {\lbrace}
        return choose{\underline}color({\dollar}, 1.5 /* was 1.35 */, base, result);
    {\rbrace} else {\lbrace}
        assert({\dollar}xcc != NULL);
        choose{\underline}xcc{\underline}color({\dollar}, {\dollar}xcc, 1.5 /* was 1.35 */, base, result);
        return TRUE;
    {\rbrace}
{\rbrace}\endCode


\Section
The method {\tt darker{\underline}color} uses {\tt choose{\underline}color} to compute a color
that is 0.6 times as bright as the color passed in as argument. The
function result is {\tt True} if a color was allocated, else {\tt False}.



\Code
Boolean  darker{\underline}color({\dollar}, Pixel  base, Pixel * result)
{\lbrace}
    if (! {\dollar}useXCC) {\lbrace}
        return choose{\underline}color({\dollar}, 0.5 /* was 0.6 */, base, result);
    {\rbrace} else {\lbrace}
        assert({\dollar}xcc != NULL);
        choose{\underline}xcc{\underline}color({\dollar}, {\dollar}xcc, 0.5 /* was 0.6 */, base, result);
        return TRUE;
    {\rbrace}
{\rbrace}\endCode


\End\Utilities
\Section
The converter {\tt cvtStringToAlignment} converts strings like `right',
`top left' and `bottom center' to values of type {\tt Alignment}.



\Macro
done(type, value) =
do {\lbrace}
        if (to-{\rangle}addr != NULL) {\lbrace}
            if (to-{\rangle}size {\langle} sizeof(type)) {\lbrace}
                to-{\rangle}size = sizeof(type);
                return False;
            {\rbrace}
            *(type*)(to-{\rangle}addr) = (value);
        {\rbrace} else {\lbrace}
            static type static{\underline}val;
            static{\underline}val = (value);
            to-{\rangle}addr = (XtPointer){\ampersand}static{\underline}val;
        {\rbrace}
        to-{\rangle}size = sizeof(type);
        return True;
    {\rbrace}while (0 )\endMacro


\Section
\Code
Boolean  cvtStringToAlignment(Display * display, XrmValuePtr  args, Cardinal * num{\underline}args, XrmValuePtr  from, XrmValuePtr  to, XtPointer * converter{\underline}data)
{\lbrace}
    Alignment a = 0;
    char c, *t, *s = (char*) from-{\rangle}addr;

    if (*num{\underline}args != 0)
        XtAppErrorMsg(XtDisplayToApplicationContext(display),
                      "cvtStringToAlignment", "wrongParameters",
                      "XtToolkitError",
                      "String to Alignment conversion needs no arguments",
                      (String*) NULL, (Cardinal*) NULL);

    while (*s) {\lbrace}
        for (; isspace(*s); s++) ;
        for (t = s; *t {\ampersand}{\ampersand} ! isspace(*t); t++) ;
        c = *t;
        *t = '{\backslash}0';
        if (XmuCompareISOLatin1(s, "top") == 0) a {\bar}= XfwfTop;
        else if (XmuCompareISOLatin1(s, "bottom") == 0) a {\bar}= XfwfBottom;
        else if (XmuCompareISOLatin1(s, "center") == 0) ; /* skip */
        else if (XmuCompareISOLatin1(s, "left") == 0) a {\bar}= XfwfLeft;
        else if (XmuCompareISOLatin1(s, "right") == 0) a {\bar}= XfwfRight;
        else {\lbrace}
            XtDisplayStringConversionWarning(display, (char*) from-{\rangle}addr, 
                                             "Alignment");
            break;
        {\rbrace}
        *t = c;
        s = t;
    {\rbrace}
    done(Alignment, a);
    /* NOTREACHED */
{\rbrace}\endCode


\Section
The converter {\tt cvtAlignmentToString} does the reverse: it convertes values of type {\tt Alignment} ({\tt int}'s) to strings.



\Code
Boolean  cvtAlignmentToString(Display * display, XrmValuePtr  args, Cardinal * num{\underline}args, XrmValuePtr  from, XrmValuePtr  to, XtPointer * converter{\underline}data)
{\lbrace}
    Alignment *a = (Alignment*) from-{\rangle}addr;

    if (*num{\underline}args != 0)
        XtAppErrorMsg(XtDisplayToApplicationContext(display),
                      "cvtAlignmentToString", "wrongParameters",
                      "XtToolkitError",
                      "Alignment to String conversion needs no arguments",
                      (String*) NULL, (Cardinal*) NULL);
    switch (*a) {\lbrace}
    case XfwfCenter: done(String, "center");
    case XfwfBottom: done(String, "bottom");
    case XfwfTop: done(String, "top");
    case XfwfLeft: done(String, "left");
    case XfwfRight: done(String, "right");
    case XfwfBottom + XfwfLeft: done(String, "bottom left");
    case XfwfBottom + XfwfRight: done(String, "bottom right");
    case XfwfTop + XfwfLeft: done(String, "top left");
    case XfwfTop + XfwfRight: done(String, "top right");
    default: done(String, "unknown");
    {\rbrace}
    /* NOTREACHED */
{\rbrace}\endCode


\Section
The following string is the set of translations that will be added
to any widget that has {\tt traversalOn} set to {\tt True}. The string is
compiled into Xt's internal representation by the {\tt class{\underline}initialize}
method.



\Code
char  extraTranslations[] = "{\backslash}
        {\langle}FocusIn{\rangle}: focusIn(){\backslash}n{\backslash}
        {\langle}FocusOut{\rangle}: focusOut(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Up: traverseUp(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Down: traverseDown(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Left: traverseLeft(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Right: traverseRight(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Next: traverseNext(){\backslash}n{\backslash}
        {\tilde}Shift{\langle}Key{\rangle}Tab: traverseNext(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Prior: traversePrev(){\backslash}n{\backslash}
        Shift{\langle}Key{\rangle}Tab: traversePrev(){\backslash}n{\backslash}
        {\langle}Key{\rangle}KP{\underline}Enter: traverseNextTop(){\backslash}n{\backslash}
        {\langle}Key{\rangle}Home: traverseHome()"\endCode


\Section
The {\tt create{\underline}bordergc} function creates a new GC for filling the
highlight border with.



\Code
create{\underline}bordergc({\dollar})
{\lbrace}
    XtGCMask mask;
    XGCValues values;

    if ({\dollar}bordergc) XtReleaseGC({\dollar}, {\dollar}bordergc);
    if ({\dollar}highlightPixmap != None) {\lbrace}
        mask = GCFillStyle {\bar} GCTile;
        values.fill{\underline}style = FillTiled;
        values.tile = {\dollar}highlightPixmap;
    {\rbrace} else {\lbrace}
        mask = GCFillStyle {\bar} GCForeground;
        values.fill{\underline}style = FillSolid;
        values.foreground = {\dollar}highlightColor;
    {\rbrace}
    {\dollar}bordergc = XtGetGC({\dollar}, mask, {\ampersand}values);
{\rbrace}\endCode


\Section
The {\tt traverse{\underline}to{\underline}direction} function returns the nearest child,
grandchild, etc. in the indicated direction that is willing to accept
the focus. It returns {\tt False} if no widget is found. The position is the
absolute coordinates, i.e., relative to the root window. The {\tt distance}
argument holds the distance from {\tt x,y} of the best widget so far. If the
function finds a better one, it will return the new distance through
this parameter.



\Code
Boolean  traverse{\underline}to{\underline}direction({\dollar}, TraversalDirection  dir, int  x, int  y, Widget * found, int * distance)
{\lbrace}
    int i;
    Position rx, ry;
    int dist;
    Boolean found{\underline}child = False;

    if (! {\dollar}traversalOn) return False;
    /*
     * First recurse to all descendants
     */
    for (i = 0; i {\langle} {\dollar}num{\underline}children; i++)
        if (XtIsSubclass({\dollar}children[i], commonWidgetClass)
            {\ampersand}{\ampersand} traverse{\underline}to{\underline}direction({\dollar}children[i], dir, x, y, found, distance))
            found{\underline}child = True;
    if (found{\underline}child) return True;
    /*
     * No child found, now check own position and distance
     */
    switch (dir) {\lbrace}
    case TraverseHome: rx = 0; ry = 0; break;
    case TraverseLeft: rx = {\dollar}width; ry = {\dollar}height/2; break;
    case TraverseDown: rx = {\dollar}width/2; ry = 0; break;
    case TraverseRight: rx = 0; ry = {\dollar}height/2; break;
    case TraverseUp: rx = {\dollar}width/2; ry = {\dollar}height; break;


    case TraverseNext:
    case TraversePrev:
    case TraverseNextTop:   
    default: break;
    {\rbrace}
    XtTranslateCoords({\dollar}, rx, ry, {\ampersand}rx, {\ampersand}ry);
    if ((dir == TraverseUp {\ampersand}{\ampersand} ry {\rangle} y)
        {\bar}{\bar} (dir == TraverseLeft {\ampersand}{\ampersand} rx {\rangle} x)
        {\bar}{\bar} (dir == TraverseDown {\ampersand}{\ampersand} ry {\langle} y)
        {\bar}{\bar} (dir == TraverseRight {\ampersand}{\ampersand} rx {\langle} x)) return False;
    dist = (rx - x)*(rx - x) + (ry - y)*(ry - y);
    if (dist {\rangle}= *distance) return False;
    /*
     * We are the best so far, but do we want the focus?
     */
    if (! {\dollar}would{\underline}accept{\underline}focus({\dollar})) return False;
    *distance = dist;
    *found = {\dollar};
    return True;
{\rbrace}\endCode


\Section
The {\tt traverse{\underline}to{\underline}next} routine looks for the {\tt current} widget among
its children. If it is found, all children following it will be tried
until one accepts the focus. If no child does, the routine will try to
ask the parent to find a sister widget instead.



\Code
traverse{\underline}to{\underline}next({\dollar}, Widget  current, Time * time)
{\lbrace}
    int i = 0;
    Widget parent = XtParent({\dollar});

    while (i {\langle} {\dollar}num{\underline}children {\ampersand}{\ampersand} {\dollar}children[i] != current) i++;
    for (i++; i {\langle} {\dollar}num{\underline}children; i++)
        if (XtCallAcceptFocus({\dollar}children[i], time)) return;
    if (XtIsSubclass(parent, commonWidgetClass))
        {\dollar}parent{\dollar}traverse(parent, TraverseNext, {\dollar}, time);
{\rbrace}\endCode


\Section
{\tt traverse{\underline}to{\underline}prev} looks for the {\tt current} widget among the children,
if it is found, all children before it will be asked in turn to accept
the focus. If none does, the parent is asked to set the focus to a
sister instead.



\Code
traverse{\underline}to{\underline}prev({\dollar}, Widget  current, Time * time)
{\lbrace}
    int i = 0;
    Widget parent = XtParent({\dollar});

    while (i {\langle} {\dollar}num{\underline}children {\ampersand}{\ampersand} {\dollar}children[i] != current) i++;
    for (i--; i {\rangle}= 0; i--)
        if (XtCallAcceptFocus({\dollar}children[i], time)) return;
    if (XtIsSubclass(parent, commonWidgetClass))
        {\dollar}parent{\dollar}traverse(parent, TraversePrev, {\dollar}, time);
{\rbrace}\endCode


\Section
\Code
traverse{\underline}to{\underline}next{\underline}top({\dollar}, Widget  current, Time * time)
{\lbrace}
    Widget parent = XtParent({\dollar});

    if (XtIsSubclass(parent, commonWidgetClass))
        {\dollar}parent{\dollar}traverse(parent, TraverseNextTop, current, time);
    else
        XtCallCallbackList({\dollar}, {\dollar}nextTop, NULL);
{\rbrace}\endCode


\Section
{\tt create{\underline}xcc} is a resource default proc. It calls {\tt XCCCreate} to
create an XCC, from which colors will be allocated. It looks for the
closest ancestor of type shell to get the visual.

However, if the resource {\tt useXCC} is false, it simply returns {\tt NULL}.



\Code
create{\underline}xcc({\dollar}, int  offset, XrmValue * value)
{\lbrace}
    Visual *visual;
    Widget w;
    static XCC xcc;

    if (! {\dollar}useXCC) {\lbrace}
        xcc = NULL;
        {\dollar}own{\underline}xcc = FALSE;
    {\rbrace} else {\lbrace}
        for (w = XtParent({\dollar}); w; w = XtParent(w)) {\lbrace}
            if (XtIsSubclass(w, commonWidgetClass)) {\lbrace}
                xcc = {\dollar}w{\dollar}xcc;
                {\dollar}own{\underline}xcc = FALSE;
                break;
            {\rbrace} else if (XtIsShell(w)) {\lbrace}
                if (((ShellWidget)w)-{\rangle}shell.visual)
                    visual = ((ShellWidget)w)-{\rangle}shell.visual;
                else
                    visual = DefaultVisualOfScreen(XtScreen({\dollar}));
                xcc = XCCCreate
                    (XtDisplay({\dollar}), visual, {\dollar}usePrivateColormap,
                     {\dollar}useStandardColormaps, {\dollar}standardColormap,
                     {\ampersand}{\dollar}colormap);
                {\dollar}own{\underline}xcc = TRUE;
                break;
            {\rbrace}
        {\rbrace}
    {\rbrace}
    value-{\rangle}addr = (XtPointer) {\ampersand}xcc;    
{\rbrace}\endCode


\End\bye
