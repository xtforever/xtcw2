\input wbuildmac.tex
\Class{Wlist4}simple list widget with wheel support
Initialisierung: 1. Aufruf von getEntry bis ein leerer String geliefert wird. Der längste String bestimmt die Puffer Breite. 2. Es wird ein Puffer erzeugt
Der Puffer ist 4 Zeilen größer als das sichtbare Fenster.
3. berechnen der aktuell sichtbaren ersten zeile in absoluten Koordinaten (top/left)
4. Anzeigen und ggf. Puffer neuberechnen



\Publicvars
\Table{Wlist4}
XtNtableStrs&XtCTableStrs&int &0 \cr
XtNfg&XtCFg&XftColor&"White"\cr
XtNnotify&XtCNotify&Callback&NULL \cr
XtNgetEntry&XtCGetEntry&Callback&NULL \cr
XtNline{\underline}distance&XtCLine{\underline}distance&Int&2 \cr
XtNtop{\underline}x&XtCTop{\underline}x&int &0 \cr
XtNtop{\underline}y&XtCTop{\underline}y&int &0 \cr
XtNmultiline&XtCMultiline&int &1 \cr
XtNline{\underline}max&XtCLine{\underline}max&int &0 \cr
XtNline{\underline}height&XtCLine{\underline}height&int &0 \cr
XtNlist{\underline}height&XtCList{\underline}height&int &0 \cr
XtNline{\underline}width&XtCLine{\underline}width&int &0 \cr
XtNtabs&XtCTabs&ArrayInt &0 \cr
XtNunit&XtCUnit&Distance &0 \cr
XtNline{\underline}bh&XtCLine{\underline}bh&int &0 \cr
XtNtitleBar&XtCTitleBar&ArrayChar &0 \cr
XtNtitleBarCol&XtCTitleBarCol&Pixel &"{\hashmark}101010"\cr
\endTable
\Section
\Publicvar{XtNtableStrs}
mstringlist


int  tableStrs = 0 

\Section
\Publicvar{XtNfg}
{\langle}XftColor{\rangle} XftColor  fg = {\langle}String{\rangle}"White"

\Section
\Publicvar{XtNnotify}
{\langle}Callback{\rangle} XtCallbackList  notify = NULL 

\Section
\Publicvar{XtNgetEntry}
{\langle}Callback{\rangle} XtCallbackList  getEntry = NULL 

\Section
\Publicvar{XtNline{\underline}distance}
{\langle}Int{\rangle} int  line{\underline}distance = 2 

\Section
\Publicvar{XtNtop{\underline}x}
int  top{\underline}x = 0 

\Section
\Publicvar{XtNtop{\underline}y}
int  top{\underline}y = 0 

\Section
\Publicvar{XtNmultiline}
Die Anzahl Texzeilen pro Feld
        

int  multiline = 1 

\Section
\Publicvar{XtNline{\underline}max}
Die Anzahl der anzuzeigenden Zeilen

        

int  line{\underline}max = 0 

\Section
\Publicvar{XtNline{\underline}height}
die Höhe einer Zeile in Pixel

        

int  line{\underline}height = 0 

\Section
\Publicvar{XtNlist{\underline}height}
die Höhe des sichtbaren Bereichs der Liste in Pixel

        

int  list{\underline}height = 0 

\Section
\Publicvar{XtNline{\underline}width}
int  line{\underline}width = 0 

\Section
\Publicvar{XtNtabs}
ArrayInt  tabs = 0 

\Section
\Publicvar{XtNunit}
Falls {\tt unit} ==0 wird die breite des Buchstaben "w" angebommen
        

Distance  unit = 0 

\Section
\Publicvar{XtNline{\underline}bh}
int  line{\underline}bh = 0 

\Section
\Publicvar{XtNtitleBar}
ArrayChar  titleBar = 0 

\Section
\Publicvar{XtNtitleBarCol}
Pixel  titleBarCol = {\langle}String{\rangle}"{\hashmark}101010"

\Section
\Publicvar{XtNrelgc}
 relgc = 

\End\Table{Wheel}
XtNxftFont&XtCXFtFont&XftFont&"Sans-22"\cr
XtNcallback&XtCCallback&Callback&NULL \cr
XtNbg{\underline}norm&XtCBg{\underline}norm&Pixel&"lightblue"\cr
XtNbg{\underline}sel&XtCBg{\underline}sel&Pixel&"yellow"\cr
XtNbg{\underline}hi&XtCBg{\underline}hi&Pixel&"red"\cr
XtNfg{\underline}norm&XtCFg{\underline}norm&Pixel&"black"\cr
XtNfg{\underline}sel&XtCFg{\underline}sel&Pixel&"green"\cr
XtNfg{\underline}hi&XtCFg{\underline}hi&Pixel&"white"\cr
XtNuser{\underline}data&XtCUser{\underline}data&Int &0 \cr
XtNfocus{\underline}group&XtCFocus{\underline}group&String &""\cr
XtNstate&XtCState&Int &0 \cr
XtNregister{\underline}focus{\underline}group&XtCRegister{\underline}focus{\underline}group&Boolean &True \cr
\endTable
\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Exports
\Section
\Code
void  wlist4{\underline}gotoxy(Widget  w, int  x, int  y)\endCode
{\lbrace}
  Wlist4WidgetClass wc = (Wlist4WidgetClass)XtClass(w);
  if( XtIsSubclass( w, wlist4WidgetClass) {\ampersand}{\ampersand} wc-{\rangle}wlist4{\underline}class.gotoxy )
    {\lbrace}
      wc-{\rangle}wlist4{\underline}class.gotoxy(w,x,y);
    {\rbrace}
{\rbrace}

\Section
\Code
void  wlist4{\underline}update{\underline}line(Widget  w, int  line)\endCode
{\lbrace}
  Wlist4WidgetClass wc = (Wlist4WidgetClass)XtClass(w);
  if( XtIsSubclass( w, wlist4WidgetClass) {\ampersand}{\ampersand} wc-{\rangle}wlist4{\underline}class.update{\underline}line )
    {\lbrace}
      wc-{\rangle}wlist4{\underline}class.update{\underline}line(w,line);
    {\rbrace}
{\rbrace}

\Section
\Code
void  wlist4{\underline}set{\underline}line{\underline}state(Widget  w, int  lineno, wheel{\underline}colors  col)\endCode
{\lbrace}
  Wlist4WidgetClass wc = (Wlist4WidgetClass)XtClass(w);
  if( XtIsSubclass(w, wlist4WidgetClass) )
      set{\underline}line{\underline}state(  w, lineno, col );
{\rbrace}

\Section
\Code
void  wlist4{\underline}clear{\underline}selection(Widget  w)\endCode
{\lbrace}
  Wlist4WidgetClass wc = (Wlist4WidgetClass)XtClass(w);
  if( XtIsSubclass(w, wlist4WidgetClass) )
      clear{\underline}selection(  w );
{\rbrace}

\Section
\Code
void  wlist4{\underline}update{\underline}all( {\dollar})\endCode
{\lbrace}
        init{\underline}graphics({\dollar});
        update{\underline}pixmap{\underline}complete({\dollar});
        {\dollar}expose({\dollar},0,0);
{\rbrace}

\End\Translations
\Section
\Code
{\langle}Btn1Motion{\rangle}: motion{\underline}start() \endCode


\Section
\Code
{\langle}Btn1Up{\rangle}: motion{\underline}end() \endCode


\Section
\Code
{\langle}EnterWindow{\rangle}: highlight() \endCode


\Section
\Code
{\langle}LeaveWindow{\rangle}: reset() \endCode


\End\Actions
\Section
\Action{highlight}\Code
void highlight({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
  if( {\dollar}state == STATE{\underline}NORMAL ) {\lbrace}
    {\dollar}state = STATE{\underline}SELECTED;
    update{\underline}widget{\underline}state({\dollar});
  {\rbrace}
{\rbrace}\endCode


\Section
\Action{reset}\Code
void reset({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
  if( {\dollar}state != STATE{\underline}NORMAL ) {\lbrace}
    {\dollar}state = STATE{\underline}NORMAL;
    update{\underline}widget{\underline}state({\dollar});
  {\rbrace}
{\rbrace}\endCode


\Section
\Action{motion{\underline}start}\Code
void motion{\underline}start({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        int y = event-{\rangle}xbutton.y;
        int lineno;
        ulong t = (ulong ) event-{\rangle}xbutton.time;
        lineno = translate{\underline}ypos{\underline}to{\underline}lineno({\dollar},y );
        if( {\dollar}drag{\underline}time == 0 ) goto restart{\underline}drag;

        /* drag startete vor über einer sekunde, seitdem keine änderung */
        /* darum: vergessen und neu starten */
        if( {\dollar}drag{\underline}update + 1000 {\langle} t ) goto restart{\underline}drag;
        {\dollar}drag{\underline}update = t;

        if( y != {\dollar}drag{\underline}last{\underline}y ) {\lbrace}
            int top = {\dollar}top{\underline}y + ({\dollar}drag{\underline}last{\underline}y - y);
            {\dollar}drag{\underline}last{\underline}y = y;
            gotoxy( {\dollar}, -1, top );
        {\rbrace}
        return; /* drag in progress */

  restart{\underline}drag:
        {\dollar}drag{\underline}start{\underline}y = event-{\rangle}xbutton.y;
        {\dollar}drag{\underline}last{\underline}y = event-{\rangle}xbutton.y;
        {\dollar}drag{\underline}time = t;
        {\dollar}drag{\underline}update = t;
        {\dollar}drag{\underline}line{\underline}start = lineno;
        /* printf( "start {\percent}d{\backslash}n",  lineno ); */
{\rbrace}\endCode


\Section
\Action{motion{\underline}end}\Code
void motion{\underline}end({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
      int y = event-{\rangle}xbutton.y;
      ulong t = (ulong ) event-{\rangle}xbutton.time;
      int lineno = translate{\underline}ypos{\underline}to{\underline}lineno({\dollar},event-{\rangle}xbutton.y );

      if( {\dollar}drag{\underline}time == 0 {\bar}{\bar} t {\langle} {\dollar}drag{\underline}time ) goto click;

      t -= {\dollar}drag{\underline}time;
      /* printf( "line: start: {\percent}d, end: {\percent}d, time: {\percent}ld{\backslash}n", {\dollar}drag{\underline}line{\underline}start, lineno, t ); */

      y -= {\dollar}drag{\underline}start{\underline}y;
      if( y {\rangle} -15 {\ampersand}{\ampersand} y {\langle} 15 ) goto click;

      /*      if( t {\langle} AUTO{\underline}SCROLL{\underline}TIME{\underline}MS ) {\lbrace} start{\underline}autoscroll({\dollar}, event-{\rangle}xbutton.y, t ); {\rbrace}
      */

      goto reset{\underline}drag;

      /* kein drag nur ein click */
      click:
      XtCallCallbackList({\dollar}, {\dollar}notify, lineno );
      // toggle{\underline}line{\underline}state( {\dollar}, lineno );
      goto reset{\underline}drag;

      reset{\underline}drag:
      {\dollar}drag{\underline}time = 0;
{\rbrace}\endCode


\Section
\Action{select{\underline}line}Der {\tt select} Action-Handler wertet auswählen eines Eintrags der Liste aus
er muss anhand der Koordinaten das Listen-Element finden auf Highlight setzen
ist schon ein anderes element ausgewählt wird dies wieder abgewählt
zusätzlich wird der {\tt notify} Handler aufgerufen.



\Code
void select{\underline}line({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        XtCallCallbackList({\dollar},{\dollar}notify,event);
{\rbrace}\endCode


\End\Imports
\Section
\Code
{\incl} {\langle}assert.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}math.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/Xft/Xft.h{\rangle}\endCode


\Section
\Code
{\incl} "xutil.h"\endCode


\Section
\Code
{\incl} "Wlist-common.h"\endCode


\Section
\Code
{\incl} "mls.h"\endCode


\Section
\Code
{\incl} "converters.h"\endCode


\End\Privatevars
\Section
\Code
 AUTO{\underline}SCROLL{\underline}TIME{\underline}MS\endCode


\Section
\Code
 PREFETCH{\underline}BUFFER\endCode


\Section
\Code
int  key{\underline}cursor\endCode


\Section
\Code
int  key{\underline}cursor{\underline}drawn\endCode


\Section
\Code
int  key{\underline}cursor{\underline}state\endCode


\Section
\Code
int  titleBarHeight\endCode


\Section
\Code
int  titleBarWidth\endCode


\Section
\Code
GC  gc{\underline}copy\endCode


\Section
\Code
Pixmap  pixmap\endCode


\Section
\Code
rect32{\underline}t  buf\endCode


\Section
\Code
XftDraw * draw\endCode


\Section
\Code
XftDraw * draw{\underline}title\endCode


\Section
\Code
Display * dpy\endCode


\Section
\Code
int  line{\underline}state\endCode


\Section
\Code
ulong  drag{\underline}time\endCode


\Section
\Code
ulong  drag{\underline}update\endCode


\Section
\Code
int  drag{\underline}line{\underline}start\endCode


\Section
\Code
int  drag{\underline}start{\underline}y\endCode


\Section
\Code
int  drag{\underline}last{\underline}y\endCode


\Section
\Code
XtIntervalId  autoscroll{\underline}id\endCode


\Section
\Code
int  pixel{\underline}to{\underline}scroll\endCode


\Section
\Code
int  autoscroll{\underline}cnt\endCode


\Section
\Code
int  tab{\underline}pos\endCode


\Section
\Code
GC  titleBarGC\endCode


\End\Methods
\Section
up, down usw. usf.


\Code
int  exec{\underline}command({\dollar}, int  cmd, int  val)
{\lbrace}
  switch( cmd ) {\lbrace}
  case WHEEL{\underline}FIRE:
    if( {\dollar}state == STATE{\underline}ARMED ) {\lbrace}
      {\dollar}state = STATE{\underline}SELECTED;
      {\dollar}key{\underline}cursor = -1;
    {\rbrace}
    else {\lbrace}
      {\dollar}state = STATE{\underline}ARMED;
      {\dollar}key{\underline}cursor = {\dollar}top{\underline}y / {\dollar}line{\underline}height;
    {\rbrace}
    update{\underline}widget{\underline}state({\dollar});
    update{\underline}cursor({\dollar});
    return 1;

  case WHEEL{\underline}LEFT:
    if( {\dollar}state != STATE{\underline}ARMED ) return 0;
    if( {\dollar}key{\underline}cursor {\rangle} 0 )
      {\dollar}key{\underline}cursor--;
    update{\underline}cursor({\dollar});
    return 1;

  case WHEEL{\underline}RIGHT:
    if( {\dollar}state != STATE{\underline}ARMED ) return 0;
    {\dollar}key{\underline}cursor++;
    update{\underline}cursor({\dollar});
    return 1;
  {\rbrace}

  return 0; /* not used */
{\rbrace}\endCode


\Section
die {\tt gotoxy} Funktion stellt die Liste ab Pos (x,y) im Fenster dar.



\Code
gotoxy({\dollar}, int  x, int  y)
{\lbrace}
        if( x {\rangle}= 0 ) {\dollar}top{\underline}x = x;
        if( y {\rangle}= 0 ) {\dollar}top{\underline}y = y;
        update{\underline}list({\dollar});
{\rbrace}\endCode


\Section
die {\tt make{\underline}visible} Funktion stellt sicher,
 das die Zeile mit der Nummer {\tt line{\underline}number} sichtbar wird.



\Code
make{\underline}visible({\dollar}, int  line{\underline}number)
{\lbrace}
  /* falls line{\underline}number im Cache -- redraw */

  /* setze buf.y so dass line{\underline}number am ende des cache liegt */
  /* setze top{\underline}y so dass letzte cache zeile angezeigt werden kann */
{\rbrace}\endCode


\Section
die {\tt update{\underline}line} Funktion stellt sicher,
 das die Zeile mit der Nummer {\tt line{\underline}number} aktuell und sichtbar ist.
 Algo: solange die liste nicht das fenster ausfüllt
 ($line_max < $height / $line_height)
 Zeile line_number in den Cache schreiben und expose() aufrufen
   Ansonsten:
  Falls die Zeile im Cache liegt, cache aktualisieren.



\Code
update{\underline}line({\dollar}, int  line{\underline}number)
{\lbrace}
  int y;

  if( ! {\dollar}draw ) return;
  update{\underline}line{\underline}state({\dollar});
  y = line{\underline}number * {\dollar}line{\underline}height;
  /* inside cache ? */
  if( y {\rangle}= {\dollar}buf.y {\ampersand}{\ampersand} y {\langle} {\dollar}buf.height + {\dollar}buf.y ) {\lbrace}
    {\dollar}draw{\underline}line({\dollar}, line{\underline}number);
    /* visible ? */
    if( y {\rangle}= {\dollar}top{\underline}y {\ampersand}{\ampersand} y {\langle} {\dollar}top{\underline}y + {\dollar}height ) {\lbrace}
      {\dollar}expose( {\dollar}, NULL, NULL );
      return;
    {\rbrace}
    /* not visible, but inside cache, move top{\underline}y */
  {\rbrace}

  /* outside cache! move top{\underline}y */
  {\dollar}top{\underline}y = y - {\dollar}height + {\dollar}line{\underline}height;
  {\dollar}expose( {\dollar}, NULL, NULL );
{\rbrace}\endCode


\Section
\Code
draw{\underline}line({\dollar}, int  line{\underline}number)
{\lbrace}
  int y = line{\underline}number * {\dollar}line{\underline}height;
  /* outside  cache ? */
  if( y {\langle} {\dollar}buf.y {\bar}{\bar} y {\rangle}= {\dollar}buf.height + {\dollar}buf.y ) return;
  y = line{\underline}number - ({\dollar}buf.y / {\dollar}line{\underline}height); /* pos. im cache */
  print{\underline}pixmap( {\dollar}, line{\underline}number, y );
{\rbrace}\endCode


\Section
\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
        /* TODO: dpy initialisierung in andere wlist widgets uebertragen */
        {\dollar}dpy = XtDisplay({\dollar});

  if( {\dollar}multiline == 0 ) {\dollar}multiline = 1;
  {\dollar}gc{\underline}copy =  XtGetGC({\dollar}, 0,0 );
  {\dollar}draw = NULL;
  /* trennlinie ist 2 pixel hoch */
  {\dollar}line{\underline}height = {\dollar}xftFont-{\rangle}height * {\dollar}multiline + {\dollar}line{\underline}distance + 2;
  {\dollar}line{\underline}state = m{\underline}create(100,1);

  update{\underline}tabs({\dollar});
  if( {\dollar}titleBar ) {\lbrace}
      {\dollar}titleBarHeight = {\dollar}xftFont-{\rangle}height+3;
      {\dollar}titleBarWidth = tabbed{\underline}str{\underline}width({\dollar}dpy, {\dollar}tab{\underline}pos, {\dollar}xftFont, m{\underline}buf({\dollar}titleBar));
   {\rbrace}
   else {\lbrace}
     {\dollar}titleBarHeight = 1;
     {\dollar}titleBarWidth  = 20;
   {\rbrace}

  if( {\dollar}width == 0 ) {\dollar}width = {\dollar}titleBarWidth;
  {\dollar}line{\underline}width = {\dollar}width;


  {\dollar}key{\underline}cursor{\underline}drawn = -1;
  {\dollar}key{\underline}cursor = -1;

  XtGCMask mask;
  XGCValues values;
  mask = GCForeground;
  values.foreground = {\dollar}titleBarCol;
  {\dollar}titleBarGC = XtGetGC({\dollar},mask,{\ampersand}values);

  if( {\dollar}height == 0 ) {\dollar}height = 20;
{\rbrace}\endCode


\Section
\Code
destroy({\dollar})
{\lbrace}
  XtReleaseGC({\dollar},{\dollar}titleBarGC);
  XtReleaseGC({\dollar},{\dollar}gc{\underline}copy);
  if( {\dollar}draw) XftDrawDestroy( {\dollar}draw );
  if( {\dollar}pixmap ) XFreePixmap( {\dollar}dpy, {\dollar}pixmap );
  if( {\dollar}titleBar ) {\lbrace} m{\underline}free( {\dollar}titleBar ); {\dollar}titleBar=0; {\rbrace}
  m{\underline}free( {\dollar}tab{\underline}pos );
  m{\underline}free( {\dollar}tabs);
  m{\underline}free( {\dollar}line{\underline}state );
{\rbrace}\endCode


\Section
\Code
realize({\dollar}, XtValueMask * mask, XSetWindowAttributes * attributes)
{\lbrace}
     XtCreateWindow({\dollar}, (unsigned int) InputOutput,
                    (Visual *) CopyFromParent, *mask, attributes);
     {\dollar}draw{\underline}title = XftDrawCreate( {\dollar}dpy, XtWindow({\dollar}),
                                  DefaultVisual({\dollar}dpy, DefaultScreen({\dollar}dpy)), None);

     init{\underline}graphics({\dollar});
     update{\underline}pixmap{\underline}complete({\dollar});
 {\rbrace}\endCode


\Section
\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace}
        if( !XtIsRealized({\dollar})) return;
        if( {\dollar}titleBar ) update{\underline}titlebar({\dollar});
        {\dollar}list{\underline}height = {\dollar}height - {\dollar}titleBarHeight;
        update{\underline}list({\dollar});
{\rbrace}\endCode


\Section
\Code
class{\underline}initialize()
{\lbrace}
          converters{\underline}init();
{\rbrace}\endCode


\Section
todo: diese funktion muss umbedingt getestet werden



\Code
resize({\dollar})
{\lbrace}
        /* der buffer sollte immer 3 zeilen größer als das window sein */
        if( XtIsRealized({\dollar}) )
          if( {\dollar}height + 3 * {\dollar}line{\underline}height {\rangle} {\dollar}buf.height {\bar}{\bar} {\dollar}width {\rangle} {\dollar}buf.width )
          {\lbrace}
                init{\underline}graphics({\dollar});
                update{\underline}pixmap{\underline}complete({\dollar});
          {\rbrace}
{\rbrace}\endCode


\Section
\Code
Boolean  set{\underline}values(Widget  old, Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
        int n = *num{\underline}args;

        /* wenn farben, font, zeilen-daten geändert worden sind,
           muss der cache aktualisiert werden
         */

         if( XtIsRealized({\dollar}) )
         while( n-- )
         {\lbrace}
                 if(strncmp( args[n].name, "tableS",6 ) == 0 )
                 {\lbrace}
                   clear{\underline}selection({\dollar});
                   update{\underline}pixmap{\underline}complete({\dollar});
                   break;
                 {\rbrace}


                 if( ( strncmp( args[n].name, "bg{\underline}",3 ) == 0 )
                     {\bar}{\bar} ( strncmp( args[n].name, "fg", 2 ) == 0 )
                     {\bar}{\bar} ( strncmp( args[n].name, "xftFont", 7 ) == 0 ) )
                  {\lbrace}
                        update{\underline}pixmap{\underline}complete({\dollar});
                        break;
                  {\rbrace}
         {\rbrace}


        return True; /* im zweifelsfall ist ein expose() immer richtig */
{\rbrace}\endCode


\End\Utilities
\Section
den Puffer um {\tt n} Zeilen nach oben kopieren


\Code
scroll{\underline}up{\underline}lines({\dollar}, int  n)
{\lbrace}
  int dst{\underline}y = 0;
  int src{\underline}y = n * {\dollar}line{\underline}height;
  int h = {\dollar}buf.height - src{\underline}y;
  assert( h {\rangle} 0 );
  XCopyArea(XtDisplay({\dollar}),{\dollar}pixmap, {\dollar}pixmap, {\dollar}gc{\underline}copy,
            0, src{\underline}y,
            {\dollar}line{\underline}width, h,
            0, dst{\underline}y );
{\rbrace}\endCode


\Section
den Puffer um {\tt n} Zeilen nach unten kopieren



\Code
scroll{\underline}down{\underline}lines({\dollar}, int  n)
{\lbrace}
  int src{\underline}y = 0;
  int dst{\underline}y = n * {\dollar}line{\underline}height;
  int h = {\dollar}buf.height - dst{\underline}y;
  assert( h {\rangle} 0 );
  XCopyArea({\dollar}dpy,{\dollar}pixmap, {\dollar}pixmap, {\dollar}gc{\underline}copy,
            0, src{\underline}y,
            {\dollar}line{\underline}width, h,
            0, dst{\underline}y );
{\rbrace}\endCode


\Section
\Code
String  get{\underline}line{\underline}intern({\dollar}, int  line)
{\lbrace}
      {\dollar}line{\underline}max = m{\underline}len({\dollar}tableStrs);
      m{\underline}setlen( {\dollar}line{\underline}state, {\dollar}line{\underline}max );
      if( m{\underline}len({\dollar}tableStrs) {\langle}= line ) return "";
      return STR({\dollar}tableStrs,line);
{\rbrace}\endCode


\Section
Zeile {\tt line} als String holen und zurückgeben.
  {\tt getEntry} callback benutzen
  {\tt line{\underline}state} buffer aktualisieren
  {\tt line{\underline}max} aktualisieren


\Code
String  get{\underline}line{\underline}str({\dollar}, int  line)
{\lbrace}
  if( {\dollar}tableStrs ) {\lbrace}
      return get{\underline}line{\underline}intern( {\dollar}, line );
  {\rbrace}

  wlist{\underline}entry{\underline}t ent;
  ent.pos = line; ent.max=0; ent.state = {\dollar}line{\underline}state; ent.data="";
  XtCallCallbackList( {\dollar}, {\dollar}getEntry, {\ampersand}ent );
  if( ent.max != m{\underline}len({\dollar}line{\underline}state) )
    m{\underline}setlen( {\dollar}line{\underline}state, ent.max );
  {\dollar}line{\underline}max = m{\underline}len({\dollar}line{\underline}state);
  return ent.data;
{\rbrace}\endCode


\Section
\Code
update{\underline}line{\underline}state({\dollar})
{\lbrace}
  get{\underline}line{\underline}str({\dollar},0);
{\rbrace}\endCode


\Section
\Code
render{\underline}multiline({\dollar}, int  tabs, XftDraw * draw, XftColor * col, XftFont * font, int  x, int  y, char * s)
{\lbrace}
  int subs=m{\underline}split(0,s, '{\backslash}n', 0 );
  int p;
  char **str;
  m{\underline}foreach( subs, p, str ) {\lbrace}
             render{\underline}mstr({\dollar},tabs,draw,col,font,x,y + {\dollar}xftFont-{\rangle}ascent,*str);
             y += {\dollar}xftFont-{\rangle}height;
  {\rbrace}
  m{\underline}free{\underline}strings(subs,0);
{\rbrace}\endCode


\Section
schreibe die zeile {\tt line} in die Puffer {\tt pixmap} an die Zeilen-position {\tt ypos}. Die Hintergrundfarbe wird durch state bestimmt, wobei 0=norm,1=sel,2=hi bedeutet.
falls keine daten vorhanden sind wird mit der hintergrundfarbe norm gefüllt.



\Code
print{\underline}pixmap({\dollar}, int  line, int  ypos)
{\lbrace}
  uint col;
  char *s = NULL;
  int x,y,w,h;

  if( line {\langle} 0 {\bar}{\bar} line {\rangle}= {\dollar}line{\underline}max )
    return;


  s = get{\underline}line{\underline}str({\dollar},line);
  if( line {\rangle}= m{\underline}len({\dollar}line{\underline}state) ) col=0;
  else
    col = UCHAR( {\dollar}line{\underline}state, line);

  if( col {\rangle} 2 ) col=0;

  TRACE(2,"line {\percent}d color {\percent}d{\backslash}n",line, col);

  x=0;
  y=ypos * {\dollar}line{\underline}height;
  w={\dollar}buf.width;
  h={\dollar}line{\underline}height;

  int font{\underline}height = {\dollar}xftFont-{\rangle}ascent +  {\dollar}xftFont-{\rangle}descent;
  int font{\underline}y{\underline}off  = (h - font{\underline}height-2) / 2 + {\dollar}xftFont-{\rangle}ascent;

  /* zeile zeichnen: Rect( x,y, w,h ) Inhalt: s, Farbe: gc */
  /*  XFillRectangle({\dollar}dpy, {\dollar}pixmap, {\dollar}gc{\underline}copy, x,y,w,h ); */
  XFillRectangle({\dollar}dpy, {\dollar}pixmap, {\dollar}gc[col], x,y,w,h );

  render{\underline}multiline({\dollar}, {\dollar}tab{\underline}pos, {\dollar}draw, {\dollar}xft{\underline}col+col, {\dollar}xftFont,
                      x, y + {\dollar}line{\underline}distance/2, s);

  XDrawLine({\dollar}dpy, {\dollar}pixmap, {\dollar}gc[1], x,y + h -2, w, y+h-2 );
  TRACE(2, "Update Line: {\percent}d{\backslash}n", line );
{\rbrace}\endCode


\Section
\Code
print({\dollar}, int  x, int  y, char * s)
{\lbrace}
  if( s {\ampersand}{\ampersand} *s )
    XftDrawStringUtf8({\dollar}draw, {\dollar}xft{\underline}col+0, {\dollar}xftFont, x,y, (FcChar8*)s,strlen(s) );
{\rbrace}\endCode


\Section
erzeuge die pixmap für den Puffer und initialisiere xftDraw


\Code
init{\underline}graphics({\dollar})
{\lbrace}
  if( {\dollar}line{\underline}width {\langle} {\dollar}width ) {\dollar}line{\underline}width = {\dollar}width;

  /* berechnen der puffer Größe: 4-Zeilen größer als das fenster */
  int height;
  height = ((int)({\dollar}height / {\dollar}line{\underline}height) + PREFETCH{\underline}BUFFER) * {\dollar}line{\underline}height;
  {\dollar}buf.height = height;
  {\dollar}buf.width  = {\dollar}line{\underline}width;
  {\dollar}buf.x = 0;
  {\dollar}buf.y = 0;

  if( {\dollar}pixmap ) XFreePixmap( {\dollar}dpy, {\dollar}pixmap );
  {\dollar}pixmap = XCreatePixmap({\dollar}dpy, XtWindow({\dollar}), {\dollar}buf.width, {\dollar}buf.height,
                         DefaultDepth({\dollar}dpy, DefaultScreen({\dollar}dpy)));

  if( {\dollar}draw) XftDrawDestroy( {\dollar}draw );
  {\dollar}draw = XftDrawCreate({\dollar}dpy, {\dollar}pixmap,
                       DefaultVisual({\dollar}dpy, DefaultScreen({\dollar}dpy)), None);
{\rbrace}\endCode


\Section
\Code
update{\underline}pixmap{\underline}complete({\dollar})
{\lbrace}
        int i = 0;
        int line{\underline}no = {\dollar}buf.y / {\dollar}line{\underline}height;
        int max = {\dollar}buf.height / {\dollar}line{\underline}height;

        update{\underline}line{\underline}state({\dollar}); // check line{\underline}max

        if( line{\underline}no + max -1 {\rangle}= {\dollar}line{\underline}max ) {\lbrace}
            max = ({\dollar}line{\underline}max - line{\underline}no);
            int h = {\dollar}buf.height - max * {\dollar}line{\underline}height;
            int w = {\dollar}buf.width;
            XFillRectangle( {\dollar}dpy, {\dollar}pixmap, {\dollar}gc[0],
                            0, max * {\dollar}line{\underline}height, w, h );
        {\rbrace}

        while( i{\langle} max ) {\lbrace}
               print{\underline}pixmap( {\dollar}, line{\underline}no+i, i );
               i++;
        {\rbrace}
{\rbrace}\endCode


\Section
{\tt update{\underline}cache} stellt fest ob der gewünschte anzuzeigende




\Section
bereich (top_x,top_y,width,height) im cache vorhanden ist.




\Section
falls nicht wird der cache aktualisiert



\Code
update{\underline}cache({\dollar})
{\lbrace}
  int ln{\underline}pos, ln{\underline}no, buf{\underline}a, buf{\underline}h, cur{\underline}buf{\underline}a, buf{\underline}d, list{\underline}h;
  update{\underline}line{\underline}state({\dollar}); // check line{\underline}max
  list{\underline}h = {\dollar}line{\underline}max * {\dollar}line{\underline}height;
  /* top{\underline}y, top{\underline}x korrigieren */
  /* falls der x-offset zu groß ist, verkleinern */
  if( {\dollar}top{\underline}x {\ampersand}{\ampersand}  ({\dollar}top{\underline}x + {\dollar}width {\rangle} {\dollar}line{\underline}width) ) {\lbrace}
    if( {\dollar}width {\langle} {\dollar}line{\underline}width ) {\dollar}top{\underline}x = {\dollar}line{\underline}width - {\dollar}width;
    else                           {\dollar}top{\underline}x = 0;
  {\rbrace}
  /* falls die liste vollständig angezeigt werden kann, */
  /* oder der rest der liste das fenster nicht füllt */
  if( {\dollar}top{\underline}y + {\dollar}list{\underline}height {\rangle} list{\underline}h ) {\lbrace}
    /* printf( "top{\underline}y:{\percent}d{\backslash}n", {\dollar}top{\underline}y ); */
    if( {\dollar}list{\underline}height {\rangle}= list{\underline}h ) {\dollar}top{\underline}y = 0;
    else                    {\dollar}top{\underline}y = list{\underline}h - {\dollar}list{\underline}height;

    /* printf( "top{\underline}y:{\percent}d{\backslash}n", {\dollar}top{\underline}y ); */
  {\rbrace}

  /* anzuzeigender bereich liegt im puffer */
  if( {\dollar}top{\underline}y + {\dollar}height {\langle}= {\dollar}buf.y + {\dollar}buf.height {\ampersand}{\ampersand}
      {\dollar}top{\underline}y {\rangle}= {\dollar}buf.y ) return;

  buf{\underline}h = {\dollar}buf.height / {\dollar}line{\underline}height;   /* anzahl zeilen im Puffer */
  cur{\underline}buf{\underline}a = {\dollar}buf.y / {\dollar}line{\underline}height;    /* erste zeile */
  buf{\underline}a = {\dollar}top{\underline}y / {\dollar}line{\underline}height;        /* neue erste zeile */
  buf{\underline}d = buf{\underline}a - cur{\underline}buf{\underline}a;            /* abstand in zeilen */

  if( buf{\underline}d == 0 ) goto update{\underline}all;

  if( buf{\underline}d {\rangle} 0 ) {\lbrace}     /* neue erste zeile {\rangle} puffer erste zeile */
    if( buf{\underline}d {\rangle}= buf{\underline}h ) goto update{\underline}all;
    scroll{\underline}up{\underline}lines({\dollar}, buf{\underline}d );
    ln{\underline}pos = buf{\underline}h - buf{\underline}d;
    ln{\underline}no = cur{\underline}buf{\underline}a + buf{\underline}h;  /* letzte zeile +1*/
  {\rbrace}
  else {\lbrace}                  /* neue erste zeile {\langle} puffer erste zeile */
    buf{\underline}d = -buf{\underline}d;
    if( buf{\underline}d {\rangle}= buf{\underline}h ) goto update{\underline}all;

            if( buf{\underline}d {\langle} PREFETCH{\underline}BUFFER ) {\lbrace}
                if( buf{\underline}a {\rangle} PREFETCH{\underline}BUFFER - buf{\underline}d ) {\lbrace}
                    buf{\underline}a -= PREFETCH{\underline}BUFFER - buf{\underline}d;
                    buf{\underline}d = PREFETCH{\underline}BUFFER;
                {\rbrace} else {\lbrace}
                    buf{\underline}d += buf{\underline}a;
                    buf{\underline}a = 0;
                {\rbrace}
            {\rbrace}

            scroll{\underline}down{\underline}lines({\dollar}, buf{\underline}d );
            ln{\underline}pos = 0; ln{\underline}no = buf{\underline}a;
            /*
            printf( "cur{\underline}buf{\underline}a={\percent}d, buf{\underline}h = {\percent}d, buf{\underline}a={\percent}d{\backslash}n", cur{\underline}buf{\underline}a, buf{\underline}h, buf{\underline}a );
            printf( "buf{\underline}d = {\percent}d, ln{\underline}no={\percent}d, ln{\underline}pos = {\percent}d{\backslash}n", buf{\underline}d, ln{\underline}no, ln{\underline}pos );
            */

        {\rbrace}

        while( buf{\underline}d-- ) {\lbrace}
            print{\underline}pixmap({\dollar}, ln{\underline}no + buf{\underline}d, ln{\underline}pos + buf{\underline}d );
        {\rbrace}

        {\dollar}buf.y = buf{\underline}a * {\dollar}line{\underline}height; /* neue startposition setzen */
        return;
        /*-----------------------------------------------------------------*/

        update{\underline}all:
        {\dollar}buf.y = buf{\underline}a * {\dollar}line{\underline}height;
        update{\underline}pixmap{\underline}complete({\dollar});
        /*-----------------------------------------------------------------*/
{\rbrace}\endCode


\Section
\Code
int  translate{\underline}ypos{\underline}to{\underline}lineno({\dollar}, int  y)
{\lbrace}
  int line{\underline}no;
  y -= {\dollar}titleBarHeight;
  line{\underline}no = ({\dollar}top{\underline}y + y) / {\dollar}line{\underline}height;
  return line{\underline}no;
{\rbrace}\endCode


\Section
\Code
autoscroll{\underline}cb(XtPointer  client{\underline}data, XtIntervalId * id)
{\lbrace}
        Widget self = (Widget) client{\underline}data;

        int new{\underline}y = {\dollar}top{\underline}y + {\dollar}pixel{\underline}to{\underline}scroll;

        if( new{\underline}y {\rangle} 0 {\ampersand}{\ampersand} new{\underline}y + {\dollar}height {\langle} {\dollar}line{\underline}max * {\dollar}line{\underline}height {\ampersand}{\ampersand} {\dollar}autoscroll{\underline}cnt {\rangle} 0 )
        {\lbrace}
                {\dollar}autoscroll{\underline}id =
                   XtAppAddTimeOut( XtWidgetToApplicationContext( self ), 100, autoscroll{\underline}cb, self );
                {\dollar}autoscroll{\underline}cnt--;
                gotoxy( {\dollar}, -1, new{\underline}y );
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
void  start{\underline}autoscroll({\dollar}, int  y, ulong  t)
{\lbrace}
        {\dollar}autoscroll{\underline}cnt  =  25;
        float speed = fabs( ({\dollar}drag{\underline}start{\underline}y - y) * 1.0 / t );
        float pixel{\underline}total = ({\dollar}drag{\underline}start{\underline}y - y) / speed;
        float pixel{\underline}per{\underline}update = 1+ pixel{\underline}total / {\dollar}autoscroll{\underline}cnt;
        printf( "drag{\underline}y0:{\percent}d, y1:{\percent}d{\backslash}n", {\dollar}drag{\underline}start{\underline}y, y );
        printf( "autoscroll started: speed:{\percent}f, pixel{\underline}total:{\percent}f{\backslash}n", speed, pixel{\underline}total );

        {\dollar}pixel{\underline}to{\underline}scroll =  pixel{\underline}per{\underline}update;

        {\dollar}autoscroll{\underline}id = XtAppAddTimeOut( XtWidgetToApplicationContext( {\dollar} ), 40, autoscroll{\underline}cb, {\dollar} );
{\rbrace}\endCode


\Section
\Code
void  set{\underline}line{\underline}state({\dollar}, int  lineno, wheel{\underline}colors  col)
{\lbrace}
        if( lineno {\langle} 0 {\bar}{\bar} lineno {\rangle}= m{\underline}len({\dollar}line{\underline}state) ) return;

        CHAR({\dollar}line{\underline}state, lineno) = col;
        /* check screen update */
        int first{\underline}line = {\dollar}buf.y / {\dollar}line{\underline}height;
        int last{\underline}line = first{\underline}line + {\dollar}buf.height / {\dollar}line{\underline}height;
        if( lineno {\rangle}= first{\underline}line {\ampersand}{\ampersand} lineno {\langle} last{\underline}line ) {\lbrace}
            print{\underline}pixmap( {\dollar}, lineno, lineno - first{\underline}line );
            update{\underline}list({\dollar});
        {\rbrace}
{\rbrace}\endCode


\Section
\Code
void  toggle{\underline}line{\underline}state({\dollar}, int  lineno)
{\lbrace}
  if( lineno {\langle} 0 {\bar}{\bar} lineno {\rangle}= m{\underline}len({\dollar}line{\underline}state) ) return;
  wheel{\underline}colors col = CHAR( {\dollar}line{\underline}state, lineno );
  col = !col;
  set{\underline}line{\underline}state( {\dollar}, lineno, col );
{\rbrace}\endCode


\Section
aus der Liste {\tt tabs} und der eingestellten {\tt unit}
  die Offsets der Tab-Stops berechnen und in
  der Liste {\tt tab{\underline}pos} speichern.


\Code
update{\underline}tabs({\dollar})
{\lbrace}
  if( ! {\dollar}tabs ) return;
  int mult = {\dollar}unit;
  if( mult == 0 ) mult = xft{\underline}textwidth( {\dollar}dpy, {\dollar}xftFont, "w" );
  if( {\dollar}tab{\underline}pos )
    m{\underline}clear({\dollar}tab{\underline}pos);
  else {\dollar}tab{\underline}pos = m{\underline}create(10,sizeof(int));

  int p,*d, v;
  m{\underline}foreach( {\dollar}tabs, p, d ) {\lbrace}
    v = (*d) * mult;
    m{\underline}put( {\dollar}tab{\underline}pos, {\ampersand}v );
  {\rbrace}
{\rbrace}\endCode


\Section
\Code
int  tabbed{\underline}str{\underline}width(Display * dpy, int  tabs, XftFont * font, char * buf)
{\lbrace}
  char **str;
  int p,
      cur{\underline}x = 0,
      cur{\underline}tab = 0;
  int subs=m{\underline}split(0,buf, '{\backslash}t', 1 );
  int last{\underline}substr = m{\underline}len(subs) {\rangle} 0 ? m{\underline}len(subs)-1 : 0;

  m{\underline}foreach( subs, p, str ) {\lbrace}
    cur{\underline}x +=  xft{\underline}textwidth( dpy, font, *str );

    if( p != last{\underline}substr {\ampersand}{\ampersand} tabs ) {\lbrace}
        while( cur{\underline}tab {\langle} m{\underline}len(tabs) ) {\lbrace}
           if( INT(tabs,cur{\underline}tab) {\rangle} cur{\underline}x )
           {\lbrace}
              cur{\underline}x = INT(tabs,cur{\underline}tab);
              break;
           {\rbrace}
           cur{\underline}tab++; /* skip this tab */
        {\rbrace}
    {\rbrace}
  {\rbrace}
  m{\underline}free{\underline}strings(subs,0);
  return cur{\underline}x;
{\rbrace}\endCode


\Section
\Code
int  render{\underline}substr({\dollar}, XftDraw * draw, XftColor * col, XftFont * font, int  x, int  y, char * s)
{\lbrace}
  int xoff;
  if(is{\underline}empty(s) ) return 0;

  xoff = xft{\underline}textwidth( {\dollar}dpy, font, s );
  XftDrawStringUtf8(draw, col, font,
                    x,y, (FcChar8*)s,strlen(s) );
  return xoff;
{\rbrace}\endCode


\Section
\Code
render{\underline}mstr({\dollar}, int  tabs, XftDraw * draw, XftColor * col, XftFont * font, int  pix{\underline}x, int  pix{\underline}y, char * buf)
{\lbrace}
  if( is{\underline}empty(buf) ) return;

  int cur{\underline}tab = 0; /* index des nächsten tab */
  int xoff;        /* größe des teil-str. in pixel */
  int cur{\underline}x = 0;   /* x-pos. des nächsten str. in pixel */
  int subs=m{\underline}split(0,buf, '{\backslash}t', 0 );
  int p;
  char **str;
  m{\underline}foreach( subs, p, str ) {\lbrace}
    if( cur{\underline}x {\rangle}= {\dollar}buf.width ) break;
    xoff = render{\underline}substr({\dollar}, draw,col,font, pix{\underline}x + cur{\underline}x, pix{\underline}y, *str);
    cur{\underline}x += xoff;
    if( tabs ) {\lbrace}
        while( cur{\underline}tab {\langle} m{\underline}len(tabs) ) {\lbrace}
           if( INT(tabs,cur{\underline}tab) {\rangle} cur{\underline}x )
           {\lbrace}
              cur{\underline}x = INT(tabs,cur{\underline}tab);
              break;
           {\rbrace}
           cur{\underline}tab++; /* skip this tab */
        {\rbrace}
    {\rbrace}
  {\rbrace}

  m{\underline}free{\underline}strings(subs,0);
{\rbrace}\endCode


\Section
\Code
update{\underline}widget{\underline}state({\dollar})
{\lbrace}
  if( {\dollar}state {\rangle}= STATE{\underline}MAX ) {\dollar}state=0;
  XSetWindowBorder( {\dollar}dpy, XtWindow({\dollar}),
                        {\dollar}pixel[{\dollar}state + COLOR{\underline}FG{\underline}MAX] );
{\rbrace}\endCode


\Section
\Code
update{\underline}titlebar({\dollar})
{\lbrace}

  uint y = {\dollar}titleBarHeight;
  XFillRectangle( {\dollar}dpy,XtWindow({\dollar}),{\dollar}titleBarGC, 0,0,{\dollar}width,y);
  XDrawLine( {\dollar}dpy,XtWindow({\dollar}),{\dollar}gc[1],0,y-2,{\dollar}width, y-2 );
  render{\underline}mstr( {\dollar}, {\dollar}tab{\underline}pos, {\dollar}draw{\underline}title, {\dollar}xft{\underline}col, {\dollar}xftFont,
               0, {\dollar}xftFont-{\rangle}ascent, m{\underline}buf({\dollar}titleBar) );
{\rbrace}\endCode


\Section
\Code
int  is{\underline}cached({\dollar}, int  lineno)
{\lbrace}
  int first{\underline}line = {\dollar}buf.y / {\dollar}line{\underline}height;
  int last{\underline}line = first{\underline}line + {\dollar}buf.height / {\dollar}line{\underline}height;
  return( lineno {\rangle}= first{\underline}line {\ampersand}{\ampersand} lineno {\langle} last{\underline}line );
{\rbrace}\endCode


\Section
\Code
int  redraw{\underline}line({\dollar}, int  lineno)
{\lbrace}
  int first{\underline}line = {\dollar}buf.y / {\dollar}line{\underline}height;
  int last{\underline}line = first{\underline}line + {\dollar}buf.height / {\dollar}line{\underline}height;
  if( lineno {\rangle}= first{\underline}line {\ampersand}{\ampersand} lineno {\langle} last{\underline}line ) {\lbrace}
    print{\underline}pixmap( {\dollar}, lineno, lineno - first{\underline}line );
    return 1;
  {\rbrace}
  return 0;
{\rbrace}\endCode


\Section
\Code
update{\underline}cursor({\dollar})
{\lbrace}
  int dirty = 0;
  if( {\dollar}key{\underline}cursor == {\dollar}key{\underline}cursor{\underline}drawn ) return;

  if( {\dollar}key{\underline}cursor{\underline}drawn {\rangle}= 0 ) {\lbrace}
    CHAR( {\dollar}line{\underline}state, {\dollar}key{\underline}cursor{\underline}drawn ) = {\dollar}key{\underline}cursor{\underline}state;
    dirty += redraw{\underline}line({\dollar},{\dollar}key{\underline}cursor{\underline}drawn);
    {\dollar}key{\underline}cursor{\underline}drawn=-1;
  {\rbrace}

  if( {\dollar}key{\underline}cursor {\rangle}= 0 ) {\lbrace}

    if( {\dollar}key{\underline}cursor {\rangle}= m{\underline}len({\dollar}line{\underline}state) )
      {\dollar}key{\underline}cursor = m{\underline}len({\dollar}line{\underline}state)-1;

    {\dollar}key{\underline}cursor{\underline}state = CHAR( {\dollar}line{\underline}state, {\dollar}key{\underline}cursor );
    CHAR({\dollar}line{\underline}state, {\dollar}key{\underline}cursor) = STATE{\underline}ARMED;
    {\dollar}key{\underline}cursor{\underline}drawn = {\dollar}key{\underline}cursor;
    redraw{\underline}line({\dollar},{\dollar}key{\underline}cursor);
    dirty = 1;
    int last{\underline}visible{\underline}line = ({\dollar}top{\underline}y + {\dollar}list{\underline}height) / {\dollar}line{\underline}height;
    printf( "crsr:{\percent}d Vis:{\percent}d{\backslash}n", {\dollar}key{\underline}cursor, last{\underline}visible{\underline}line );

    if( {\dollar}key{\underline}cursor {\rangle}= last{\underline}visible{\underline}line ) {\lbrace}
      int y=({\dollar}key{\underline}cursor+1) * {\dollar}line{\underline}height - {\dollar}list{\underline}height;
      {\dollar}gotoxy({\dollar},-1,y); dirty=0;
    {\rbrace}
    else if( {\dollar}key{\underline}cursor {\langle} ({\dollar}top{\underline}y / {\dollar}line{\underline}height) )
      {\lbrace}
        {\dollar}gotoxy({\dollar},-1,{\dollar}key{\underline}cursor*{\dollar}line{\underline}height); dirty=0;
      {\rbrace}
  {\rbrace}

  if( dirty ) update{\underline}list({\dollar});
{\rbrace}\endCode


\Section
\Code
clear{\underline}selection({\dollar})
{\lbrace}
        int len = m{\underline}len({\dollar}line{\underline}state);
        while( len-- ) CHAR({\dollar}line{\underline}state,len)=0;
{\rbrace}\endCode


\Section
\Code
update{\underline}list({\dollar})
{\lbrace}
  uint bx = 1;
  uint by = {\dollar}titleBarHeight;
  update{\underline}cache({\dollar});
  XCopyArea({\dollar}dpy,{\dollar}pixmap,XtWindow({\dollar}), {\dollar}gc{\underline}copy,
            {\dollar}top{\underline}x, {\dollar}top{\underline}y - {\dollar}buf.y, {\dollar}width -2*bx, {\dollar}height-by,
            bx, by );
{\rbrace}\endCode


\End\bye
