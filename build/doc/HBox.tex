\input wbuildmac.tex
\Class{HBox}This widget puts the child widgets from left to right in a box.
  each widget is assigned the same size.
  When a child widget is created the function change_manged is called by Xt.
  change_managed() calls calculate_size() to determine its size.
  then change_managed() calls XtMakeGeometryRequest() to tell its parent
  that this widget wants another size. the parent shall resize this widget.
  after that all childs are resized.
  XtMakeGeometryRequest() leads to call of geometry_manager() of the parent
  widget. The parent widgets decides what to do. hopefully the parent will
  accept the given size and will resize itself and its child.
  calculate_size() calls XtQueryGeometry() on every child.
  This leads to a call to the query_geometry() method of the child.
  The child widget will respond with its size.



\Publicvars
\Table{HBox}
XtNhgap&XtCHgap&Distance &"2mm"\cr
\endTable
\Section
\Publicvar{XtNhgap}
the distance between the child widgets 


Distance  hgap = {\langle}String{\rangle}"2mm"

\End\Table{Composite}
XtNchildren&XtCChildren&WidgetList &NULL \cr
insertPosition&XtCInsertPosition&XTOrderProc &NULL \cr
numChildren&XtCNumChildren&Cardinal &0 \cr
\endTable
\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Imports
\Section
\Code
{\incl} "converters.h"\endCode


\Section
\Code
{\incl} "mls.h"\endCode


\End\Privatevars
\Section
\Code
int  total{\underline}height\endCode


\Section
\Code
int  total{\underline}width\endCode


\Section
\Code
 DB\endCode


\End\Methods
\Section
\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}
        if( ! {\dollar}width ) {\dollar}width=10;
        if( ! {\dollar}height ) {\dollar}height = 10;
{\rbrace}\endCode


\Section
\Code
resize({\dollar})
{\lbrace}
        TRACE(2, "HBOX {\percent}s: {\percent}dx{\percent}d{\backslash}n", XtName({\dollar}),
                   {\dollar}width, {\dollar}height );
        do{\underline}layout({\dollar});
{\rbrace}\endCode


\Section
\Code
change{\underline}managed({\dollar})
{\lbrace}
        XtWidgetGeometry request, reply;
        XtGeometryResult result;
        if ({\dollar}num{\underline}children == 0) return;

        calculate{\underline}size({\dollar});
        if(DB) printf("{\percent}s: {\percent}s size prefered: {\percent}u {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, {\dollar}total{\underline}width, {\dollar}total{\underline}height );

        request.request{\underline}mode = CWWidth {\bar} CWHeight;
        request.width =  {\dollar}total{\underline}width;
        request.height = {\dollar}total{\underline}height;
        XtMakeGeometryRequest({\dollar}, {\ampersand}request, {\ampersand}reply);
        if(DB) printf("{\percent}s: {\percent}s size granted: {\percent}u {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, {\dollar}width, {\dollar}height );
        {\dollar}total{\underline}width = {\dollar}width; {\dollar}total{\underline}height = {\dollar}height;
        do{\underline}layout({\dollar});
{\rbrace}\endCode


\Section
When our parent asks for this widget's preferred geometry,
simply return the geometry as indicated by our childs.
Currently, the method always returns {\tt XtGeometryAlmost}. It doesn't bother
to check if the preferred geometry is equal to the current geometry (in
which case it should really return {\tt XtGeometryNo}) or if the preferred
geometry is equal to what the parent proposed (in which case a return of
{\tt XtGeometryYes} should have been given.

It seems that no harm is done by always returning {\tt XtGeometryAlmost} and
letting Xt figure out what really needs to be changed.



\Code
XtGeometryResult  query{\underline}geometry({\dollar}, XtWidgetGeometry * request, XtWidgetGeometry * reply)
{\lbrace}
        /* every proposed geometry is fine */
    if ({\dollar}num{\underline}children == 0) return XtGeometryYes;

    reply-{\rangle}request{\underline}mode = CWX {\bar} CWY {\bar} CWWidth {\bar} CWHeight;
    calculate{\underline}size({\dollar});
    reply-{\rangle}x=0; reply-{\rangle}y=0;
    reply-{\rangle}width =  {\dollar}total{\underline}width;
    reply-{\rangle}height = {\dollar}total{\underline}height;

    TRACE(2, "{\percent}s: parent request is: {\percent}dx{\percent}d", XtName({\dollar}),
             request-{\rangle}width,
             request-{\rangle}width );

    TRACE(2, "{\percent}s: our prefered size is {\percent}dx{\percent}d", XtName({\dollar}),
                  {\dollar}total{\underline}width,
                  {\dollar}total{\underline}height );
    return XtGeometryAlmost;
{\rbrace}\endCode


\Section
If a child requests to be resized, the request is always granted. We
ignore stacking order.



\Code
XtGeometryResult  geometry{\underline}manager(Widget  child, XtWidgetGeometry * request, XtWidgetGeometry * reply)
{\lbrace}
    /* Widget {\dollar} = XtParent(child); automatically inserted by wbuild */
    Dimension wd, ht, bw;
    Position x, y;

    /* Get complete geometry, from request or current value */
    x = request-{\rangle}request{\underline}mode {\ampersand} CWX ? request-{\rangle}x : {\dollar}child{\dollar}x;
    y = request-{\rangle}request{\underline}mode {\ampersand} CWY ? request-{\rangle}y : {\dollar}child{\dollar}y;
    wd = request-{\rangle}request{\underline}mode {\ampersand} CWWidth ? request-{\rangle}width : {\dollar}child{\dollar}width;
    ht = request-{\rangle}request{\underline}mode {\ampersand} CWHeight ? request-{\rangle}height : {\dollar}child{\dollar}height;
    bw = request-{\rangle}request{\underline}mode {\ampersand} CWBorderWidth ? request-{\rangle}border{\underline}width
        : {\dollar}child{\dollar}border{\underline}width;

    if(DB) printf("{\percent}s: {\percent}s Child: {\percent}s wanted size: {\percent}u {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, XtName(child), wd, ht );

    XtConfigureWidget(child, x, y, wd, ht, bw);
    return XtGeometryDone;
{\rbrace}\endCode


\Section
\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace}
        if(DB) printf("{\percent}s: {\percent}s size: {\percent}u {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, {\dollar}width, {\dollar}height );
{\rbrace}\endCode


\End\Utilities
\Section
ask children for their preferred size,
  then calculate our preffered size



\Code
calculate{\underline}size({\dollar})
{\lbrace}
    int i,w,h, max{\underline}w, max{\underline}h;
    XtWidgetGeometry reply;
    Widget child;

    max{\underline}w = max{\underline}h = 0;

    if( {\dollar}num{\underline}children == 0 ) return;

    for (i = 0; i {\langle} {\dollar}num{\underline}children; i++) {\lbrace}
        child = {\dollar}children[i];
        (void) XtQueryGeometry(child, NULL, {\ampersand}reply);
        w = reply.width + reply.border{\underline}width * 2;
        h = reply.height+ reply.border{\underline}width * 2;

        if(DB) printf("{\percent}s: {\percent}s Child: {\percent}s size: {\percent}u {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, XtName(child), w, h );

        if( max{\underline}w {\langle} w ) max{\underline}w = w;
        if( max{\underline}h {\langle} h ) max{\underline}h = h;
    {\rbrace}

    {\dollar}total{\underline}height = max{\underline}h;
    {\dollar}total{\underline}width = ({\dollar}num{\underline}children - 1) * {\dollar}hgap + max{\underline}w * {\dollar}num{\underline}children;

    TRACE(2,"{\percent}s: {\percent}s {\percent}dx{\percent}d gap={\percent}d{\backslash}n",{\underline}{\underline}func{\underline}{\underline}, {\dollar}name, {\dollar}total{\underline}width, {\dollar}total{\underline}height, {\dollar}hgap );
{\rbrace}\endCode


\Section
\Code
do{\underline}layout({\dollar})
{\lbrace}
    int i,b;
    Widget child;
    Dimension x;
    float width;

    if( {\dollar}num{\underline}children == 0 ) return;



    width =  {\dollar}width - ({\dollar}num{\underline}children - 1) * {\dollar}hgap;
    width /= {\dollar}num{\underline}children;

    if(DB) printf("{\percent}s: {\percent}s child size: {\percent}f {\percent}u{\backslash}n", XtName({\dollar}), {\underline}{\underline}func{\underline}{\underline}, width, {\dollar}height );

    x=0;
    for (i = 0; i {\langle} {\dollar}num{\underline}children; i++) {\lbrace}
        child = {\dollar}children[i];
        b={\dollar}child{\dollar}border{\underline}width;
        XtConfigureWidget(child, x, 0, width - 2 *b,
                          {\dollar}height - 2*b, b );
        x += width + {\dollar}hgap;
    {\rbrace}
{\rbrace}\endCode


\End\bye
